# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Tell mypy (a type checker) to ignore all errors from this file.
# See https://mypy.readthedocs.io/en/stable/config_file.html?highlight=ignore-errors#confval-ignore_errors
# mypy: ignore-errors

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime

# Used for default argument values
DEFAULT = object()


class RustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return rust_call(_UniFFILib.ffi_breez_sdk_715c_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return rust_call(_UniFFILib.ffi_breez_sdk_715c_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return rust_call(_UniFFILib.ffi_breez_sdk_715c_rustbuffer_free, self)

    def __str__(self):
        return "RustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def allocWithBuilder():
        """Context-manger to allocate a buffer using a RustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = RustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consumeWithStream(self):
        """Context-manager to consume a buffer using a RustBufferStream.

        The RustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = RustBufferStream(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer after consuming")
        finally:
            self.free()


class ForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "ForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class RustBufferStream(object):
    """
    Helper for structured reading of bytes from a RustBuffer
    """

    def __init__(self, rbuf):
        self.rbuf = rbuf
        self.offset = 0

    def remaining(self):
        return self.rbuf.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.rbuf.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.rbuf.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.rbuf.len:
            raise InternalError("read past end of rust buffer")
        data = self.rbuf.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def readI8(self):
        return self._unpack_from(1, ">b")

    def readU8(self):
        return self._unpack_from(1, ">B")

    def readI16(self):
        return self._unpack_from(2, ">h")

    def readU16(self):
        return self._unpack_from(2, ">H")

    def readI32(self):
        return self._unpack_from(4, ">i")

    def readU32(self):
        return self._unpack_from(4, ">I")

    def readI64(self):
        return self._unpack_from(8, ">q")

    def readU64(self):
        return self._unpack_from(8, ">Q")

    def readFloat(self):
        v = self._unpack_from(4, ">f")
        return v

    def readDouble(self):
        return self._unpack_from(8, ">d")


class RustBufferBuilder(object):
    """
    Helper for structured writing of bytes into a RustBuffer.
    """

    def __init__(self):
        self.rbuf = RustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, numBytes):
        if self.rbuf.len + numBytes > self.rbuf.capacity:
            self.rbuf = RustBuffer.reserve(self.rbuf, numBytes)
        yield None
        self.rbuf.len += numBytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def writeI8(self, v):
        self._pack_into(1, ">b", v)

    def writeU8(self, v):
        self._pack_into(1, ">B", v)

    def writeI16(self, v):
        self._pack_into(2, ">h", v)

    def writeU16(self, v):
        self._pack_into(2, ">H", v)

    def writeI32(self, v):
        self._pack_into(4, ">i", v)

    def writeU32(self, v):
        self._pack_into(4, ">I", v)

    def writeI64(self, v):
        self._pack_into(8, ">q", v)

    def writeU64(self, v):
        self._pack_into(8, ">Q", v)

    def writeFloat(self, v):
        self._pack_into(4, ">f", v)

    def writeDouble(self, v):
        self._pack_into(8, ">d", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class RustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", RustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == RustCallStatus.CALL_SUCCESS:
            return "RustCallStatus(CALL_SUCCESS)"
        elif self.code == RustCallStatus.CALL_ERROR:
            return "RustCallStatus(CALL_ERROR)"
        elif self.code == RustCallStatus.CALL_PANIC:
            return "RustCallStatus(CALL_PANIC)"
        else:
            return "RustCallStatus(<invalid code>)"

def rust_call(fn, *args):
    # Call a rust function
    return rust_call_with_error(None, fn, *args)

def rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the FfiConverter for the error class that corresponds to the result.
    call_status = RustCallStatus(code=RustCallStatus.CALL_SUCCESS, error_buf=RustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    if call_status.code == RustCallStatus.CALL_SUCCESS:
        return result
    elif call_status.code == RustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == RustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a RustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = FfiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid RustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: RustBuffer, buf_ptr: *mut RustBuffer) -> int`
FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, RustBuffer, ctypes.POINTER(RustBuffer))
# Types conforming to `FfiConverterPrimitive` pass themselves directly over the FFI.
class FfiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

# Helper class for wrapper types that will always go through a RustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class FfiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consumeWithStream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with RustBuffer.allocWithBuilder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code,
# and the FFI Function declarations in a com.sun.jna.Library.
# This is how we find and load the dynamic library provided by the component.
# For now we just look it up by name.
#
# XXX TODO: This will probably grow some magic for resolving megazording in future.
# E.g. we might start by looking for the named component in `libuniffi.so` and if
# that fails, fall back to loading it separately from `lib${componentName}.so`.

from pathlib import Path

def loadIndirect():
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    lib = libname.format("breez_sdk_bindings")
    path = str(Path(__file__).parent / lib)
    return ctypes.cdll.LoadLibrary(path)

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniFFILib = loadIndirect()
_UniFFILib.ffi_breez_sdk_715c_BlockingBreezServices_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_breez_sdk_715c_BlockingBreezServices_object_free.restype = None
_UniFFILib.breez_sdk_715c_BlockingBreezServices_disconnect.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_disconnect.restype = None
_UniFFILib.breez_sdk_715c_BlockingBreezServices_send_payment.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_send_payment.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_send_spontaneous_payment.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_send_spontaneous_payment.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_receive_payment.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_receive_payment.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_pay_lnurl.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_uint64,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_pay_lnurl.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_withdraw_lnurl.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_uint64,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_withdraw_lnurl.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_lnurl_auth.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_lnurl_auth.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_node_info.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_node_info.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_sign_message.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_sign_message.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_check_message.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_check_message.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_backup_status.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_backup_status.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_backup.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_backup.restype = None
_UniFFILib.breez_sdk_715c_BlockingBreezServices_payment_by_hash.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_payment_by_hash.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_list_payments.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_list_payments.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_sweep.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_sweep.restype = None
_UniFFILib.breez_sdk_715c_BlockingBreezServices_fetch_fiat_rates.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_fetch_fiat_rates.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_list_fiat_currencies.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_list_fiat_currencies.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_list_lsps.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_list_lsps.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_connect_lsp.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_connect_lsp.restype = None
_UniFFILib.breez_sdk_715c_BlockingBreezServices_fetch_lsp_info.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_fetch_lsp_info.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_lsp_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_lsp_id.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_lsp_info.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_lsp_info.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_close_lsp_channels.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_close_lsp_channels.restype = None
_UniFFILib.breez_sdk_715c_BlockingBreezServices_receive_onchain.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_receive_onchain.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_in_progress_swap.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_in_progress_swap.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_list_refundables.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_list_refundables.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_refund.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.c_uint32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_refund.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_fetch_reverse_swap_fees.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_fetch_reverse_swap_fees.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_in_progress_reverse_swaps.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_in_progress_reverse_swaps.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_send_onchain.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    RustBuffer,
    RustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_send_onchain.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_execute_dev_command.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_execute_dev_command.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_sync.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_sync.restype = None
_UniFFILib.breez_sdk_715c_BlockingBreezServices_recommended_fees.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_recommended_fees.restype = RustBuffer
_UniFFILib.breez_sdk_715c_BlockingBreezServices_buy_bitcoin.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_BlockingBreezServices_buy_bitcoin.restype = RustBuffer
_UniFFILib.ffi_breez_sdk_715c_LogStream_init_callback.argtypes = (
    FOREIGN_CALLBACK_T,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_breez_sdk_715c_LogStream_init_callback.restype = None
_UniFFILib.ffi_breez_sdk_715c_EventListener_init_callback.argtypes = (
    FOREIGN_CALLBACK_T,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_breez_sdk_715c_EventListener_init_callback.restype = None
_UniFFILib.breez_sdk_715c_connect.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_connect.restype = ctypes.c_void_p
_UniFFILib.breez_sdk_715c_set_log_stream.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_set_log_stream.restype = None
_UniFFILib.breez_sdk_715c_parse_invoice.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_parse_invoice.restype = RustBuffer
_UniFFILib.breez_sdk_715c_parse_input.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_parse_input.restype = RustBuffer
_UniFFILib.breez_sdk_715c_mnemonic_to_seed.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_mnemonic_to_seed.restype = RustBuffer
_UniFFILib.breez_sdk_715c_default_config.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.breez_sdk_715c_default_config.restype = RustBuffer
_UniFFILib.ffi_breez_sdk_715c_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_breez_sdk_715c_rustbuffer_alloc.restype = RustBuffer
_UniFFILib.ffi_breez_sdk_715c_rustbuffer_from_bytes.argtypes = (
    ForeignBytes,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_breez_sdk_715c_rustbuffer_from_bytes.restype = RustBuffer
_UniFFILib.ffi_breez_sdk_715c_rustbuffer_free.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_breez_sdk_715c_rustbuffer_free.restype = None
_UniFFILib.ffi_breez_sdk_715c_rustbuffer_reserve.argtypes = (
    RustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_breez_sdk_715c_rustbuffer_reserve.restype = RustBuffer

# Public interface members begin here.


class FfiConverterUInt8(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU8()

    @staticmethod
    def write(value, buf):
        buf.writeU8(value)

class FfiConverterUInt16(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU16()

    @staticmethod
    def write(value, buf):
        buf.writeU16(value)

class FfiConverterUInt32(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU32()

    @staticmethod
    def write(value, buf):
        buf.writeU32(value)

class FfiConverterInt32(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readI32()

    @staticmethod
    def write(value, buf):
        buf.writeI32(value)

class FfiConverterUInt64(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU64()

    @staticmethod
    def write(value, buf):
        buf.writeU64(value)

class FfiConverterInt64(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readI64()

    @staticmethod
    def write(value, buf):
        buf.writeI64(value)

class FfiConverterDouble(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readDouble()

    @staticmethod
    def write(value, buf):
        buf.writeDouble(value)

class FfiConverterBool:
    @classmethod
    def read(cls, buf):
        return cls.lift(buf.readU8())

    @classmethod
    def write(cls, value, buf):
        buf.writeU8(cls.lower(value))

    @staticmethod
    def lift(value):
        return int(value) != 0

    @staticmethod
    def lower(value):
        return 1 if value else 0

class FfiConverterString:
    @staticmethod
    def read(buf):
        size = buf.readI32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8Bytes = buf.read(size)
        return utf8Bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8Bytes = value.encode("utf-8")
        buf.writeI32(len(utf8Bytes))
        buf.write(utf8Bytes)

    @staticmethod
    def lift(buf):
        with buf.consumeWithStream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with RustBuffer.allocWithBuilder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()



class BlockingBreezServices(object):

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_breez_sdk_715c_BlockingBreezServices_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def disconnect(self, ):
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_disconnect,self._pointer,)
    
    def send_payment(self, bolt11,amount_sats):
        bolt11 = bolt11
        
        amount_sats = (None if amount_sats is None else int(amount_sats))
        
        return FfiConverterTypePayment.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_send_payment,self._pointer,
        FfiConverterString.lower(bolt11),
        FfiConverterOptionalUInt64.lower(amount_sats))
        )
    def send_spontaneous_payment(self, node_id,amount_sats):
        node_id = node_id
        
        amount_sats = int(amount_sats)
        
        return FfiConverterTypePayment.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_send_spontaneous_payment,self._pointer,
        FfiConverterString.lower(node_id),
        FfiConverterUInt64.lower(amount_sats))
        )
    def receive_payment(self, req_data):
        req_data = req_data
        
        return FfiConverterTypeReceivePaymentResponse.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_receive_payment,self._pointer,
        FfiConverterTypeReceivePaymentRequest.lower(req_data))
        )
    def pay_lnurl(self, req_data,amount_sats,comment):
        req_data = req_data
        
        amount_sats = int(amount_sats)
        
        comment = (None if comment is None else comment)
        
        return FfiConverterTypeLnUrlPayResult.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_pay_lnurl,self._pointer,
        FfiConverterTypeLnUrlPayRequestData.lower(req_data),
        FfiConverterUInt64.lower(amount_sats),
        FfiConverterOptionalString.lower(comment))
        )
    def withdraw_lnurl(self, req_data,amount_sats,description):
        req_data = req_data
        
        amount_sats = int(amount_sats)
        
        description = (None if description is None else description)
        
        return FfiConverterTypeLnUrlCallbackStatus.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_withdraw_lnurl,self._pointer,
        FfiConverterTypeLnUrlWithdrawRequestData.lower(req_data),
        FfiConverterUInt64.lower(amount_sats),
        FfiConverterOptionalString.lower(description))
        )
    def lnurl_auth(self, req_data):
        req_data = req_data
        
        return FfiConverterTypeLnUrlCallbackStatus.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_lnurl_auth,self._pointer,
        FfiConverterTypeLnUrlAuthRequestData.lower(req_data))
        )
    def node_info(self, ):
        return FfiConverterTypeNodeState.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_node_info,self._pointer,)
        )
    def sign_message(self, request):
        request = request
        
        return FfiConverterTypeSignMessageResponse.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_sign_message,self._pointer,
        FfiConverterTypeSignMessageRequest.lower(request))
        )
    def check_message(self, request):
        request = request
        
        return FfiConverterTypeCheckMessageResponse.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_check_message,self._pointer,
        FfiConverterTypeCheckMessageRequest.lower(request))
        )
    def backup_status(self, ):
        return FfiConverterTypeBackupStatus.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_backup_status,self._pointer,)
        )
    def backup(self, ):
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_backup,self._pointer,)
    
    def payment_by_hash(self, hash):
        hash = hash
        
        return FfiConverterOptionalTypePayment.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_payment_by_hash,self._pointer,
        FfiConverterString.lower(hash))
        )
    def list_payments(self, filter,from_timestamp,to_timestamp):
        filter = filter
        
        from_timestamp = (None if from_timestamp is None else int(from_timestamp))
        
        to_timestamp = (None if to_timestamp is None else int(to_timestamp))
        
        return FfiConverterSequenceTypePayment.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_list_payments,self._pointer,
        FfiConverterTypePaymentTypeFilter.lower(filter),
        FfiConverterOptionalInt64.lower(from_timestamp),
        FfiConverterOptionalInt64.lower(to_timestamp))
        )
    def sweep(self, to_address,fee_rate_sats_per_vbyte):
        to_address = to_address
        
        fee_rate_sats_per_vbyte = int(fee_rate_sats_per_vbyte)
        
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_sweep,self._pointer,
        FfiConverterString.lower(to_address),
        FfiConverterUInt64.lower(fee_rate_sats_per_vbyte))
    
    def fetch_fiat_rates(self, ):
        return FfiConverterSequenceTypeRate.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_fetch_fiat_rates,self._pointer,)
        )
    def list_fiat_currencies(self, ):
        return FfiConverterSequenceTypeFiatCurrency.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_list_fiat_currencies,self._pointer,)
        )
    def list_lsps(self, ):
        return FfiConverterSequenceTypeLspInformation.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_list_lsps,self._pointer,)
        )
    def connect_lsp(self, lsp_id):
        lsp_id = lsp_id
        
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_connect_lsp,self._pointer,
        FfiConverterString.lower(lsp_id))
    
    def fetch_lsp_info(self, lsp_id):
        lsp_id = lsp_id
        
        return FfiConverterOptionalTypeLspInformation.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_fetch_lsp_info,self._pointer,
        FfiConverterString.lower(lsp_id))
        )
    def lsp_id(self, ):
        return FfiConverterOptionalString.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_lsp_id,self._pointer,)
        )
    def lsp_info(self, ):
        return FfiConverterTypeLspInformation.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_lsp_info,self._pointer,)
        )
    def close_lsp_channels(self, ):
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_close_lsp_channels,self._pointer,)
    
    def receive_onchain(self, req):
        req = req
        
        return FfiConverterTypeSwapInfo.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_receive_onchain,self._pointer,
        FfiConverterTypeReceiveOnchainRequest.lower(req))
        )
    def in_progress_swap(self, ):
        return FfiConverterOptionalTypeSwapInfo.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_in_progress_swap,self._pointer,)
        )
    def list_refundables(self, ):
        return FfiConverterSequenceTypeSwapInfo.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_list_refundables,self._pointer,)
        )
    def refund(self, swap_address,to_address,sat_per_vbyte):
        swap_address = swap_address
        
        to_address = to_address
        
        sat_per_vbyte = int(sat_per_vbyte)
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_refund,self._pointer,
        FfiConverterString.lower(swap_address),
        FfiConverterString.lower(to_address),
        FfiConverterUInt32.lower(sat_per_vbyte))
        )
    def fetch_reverse_swap_fees(self, req):
        req = req
        
        return FfiConverterTypeReverseSwapPairInfo.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_fetch_reverse_swap_fees,self._pointer,
        FfiConverterTypeReverseSwapFeesRequest.lower(req))
        )
    def in_progress_reverse_swaps(self, ):
        return FfiConverterSequenceTypeReverseSwapInfo.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_in_progress_reverse_swaps,self._pointer,)
        )
    def send_onchain(self, amount_sat,onchain_recipient_address,pair_hash,sat_per_vbyte):
        amount_sat = int(amount_sat)
        
        onchain_recipient_address = onchain_recipient_address
        
        pair_hash = pair_hash
        
        sat_per_vbyte = int(sat_per_vbyte)
        
        return FfiConverterTypeReverseSwapInfo.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_send_onchain,self._pointer,
        FfiConverterUInt64.lower(amount_sat),
        FfiConverterString.lower(onchain_recipient_address),
        FfiConverterString.lower(pair_hash),
        FfiConverterUInt64.lower(sat_per_vbyte))
        )
    def execute_dev_command(self, command):
        command = command
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_execute_dev_command,self._pointer,
        FfiConverterString.lower(command))
        )
    def sync(self, ):
        rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_sync,self._pointer,)
    
    def recommended_fees(self, ):
        return FfiConverterTypeRecommendedFees.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_recommended_fees,self._pointer,)
        )
    def buy_bitcoin(self, req):
        req = req
        
        return FfiConverterTypeBuyBitcoinResponse.lift(
            rust_call_with_error(
    FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_BlockingBreezServices_buy_bitcoin,self._pointer,
        FfiConverterTypeBuyBitcoinRequest.lower(req))
        )
    


class FfiConverterTypeBlockingBreezServices:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, BlockingBreezServices):
            raise TypeError("Expected BlockingBreezServices instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return BlockingBreezServices._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class AesSuccessActionDataDecrypted:

    def __init__(self, description, plaintext):
        self.description = description
        self.plaintext = plaintext

    def __str__(self):
        return "AesSuccessActionDataDecrypted(description={}, plaintext={})".format(self.description, self.plaintext)

    def __eq__(self, other):
        if self.description != other.description:
            return False
        if self.plaintext != other.plaintext:
            return False
        return True

class FfiConverterTypeAesSuccessActionDataDecrypted(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AesSuccessActionDataDecrypted(
            description=FfiConverterString.read(buf),
            plaintext=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.description, buf)
        FfiConverterString.write(value.plaintext, buf)


class BackupFailedData:

    def __init__(self, error):
        self.error = error

    def __str__(self):
        return "BackupFailedData(error={})".format(self.error)

    def __eq__(self, other):
        if self.error != other.error:
            return False
        return True

class FfiConverterTypeBackupFailedData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BackupFailedData(
            error=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.error, buf)


class BackupStatus:

    def __init__(self, backed_up, last_backup_time):
        self.backed_up = backed_up
        self.last_backup_time = last_backup_time

    def __str__(self):
        return "BackupStatus(backed_up={}, last_backup_time={})".format(self.backed_up, self.last_backup_time)

    def __eq__(self, other):
        if self.backed_up != other.backed_up:
            return False
        if self.last_backup_time != other.last_backup_time:
            return False
        return True

class FfiConverterTypeBackupStatus(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BackupStatus(
            backed_up=FfiConverterBool.read(buf),
            last_backup_time=FfiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterBool.write(value.backed_up, buf)
        FfiConverterOptionalUInt64.write(value.last_backup_time, buf)


class BitcoinAddressData:

    def __init__(self, address, network, amount_sat, label, message):
        self.address = address
        self.network = network
        self.amount_sat = amount_sat
        self.label = label
        self.message = message

    def __str__(self):
        return "BitcoinAddressData(address={}, network={}, amount_sat={}, label={}, message={})".format(self.address, self.network, self.amount_sat, self.label, self.message)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.network != other.network:
            return False
        if self.amount_sat != other.amount_sat:
            return False
        if self.label != other.label:
            return False
        if self.message != other.message:
            return False
        return True

class FfiConverterTypeBitcoinAddressData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BitcoinAddressData(
            address=FfiConverterString.read(buf),
            network=FfiConverterTypeNetwork.read(buf),
            amount_sat=FfiConverterOptionalUInt64.read(buf),
            label=FfiConverterOptionalString.read(buf),
            message=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.address, buf)
        FfiConverterTypeNetwork.write(value.network, buf)
        FfiConverterOptionalUInt64.write(value.amount_sat, buf)
        FfiConverterOptionalString.write(value.label, buf)
        FfiConverterOptionalString.write(value.message, buf)


class BuyBitcoinRequest:

    def __init__(self, provider, opening_fee_params):
        self.provider = provider
        self.opening_fee_params = opening_fee_params

    def __str__(self):
        return "BuyBitcoinRequest(provider={}, opening_fee_params={})".format(self.provider, self.opening_fee_params)

    def __eq__(self, other):
        if self.provider != other.provider:
            return False
        if self.opening_fee_params != other.opening_fee_params:
            return False
        return True

class FfiConverterTypeBuyBitcoinRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BuyBitcoinRequest(
            provider=FfiConverterTypeBuyBitcoinProvider.read(buf),
            opening_fee_params=FfiConverterOptionalTypeOpeningFeeParams.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeBuyBitcoinProvider.write(value.provider, buf)
        FfiConverterOptionalTypeOpeningFeeParams.write(value.opening_fee_params, buf)


class BuyBitcoinResponse:

    def __init__(self, url, opening_fee_params):
        self.url = url
        self.opening_fee_params = opening_fee_params

    def __str__(self):
        return "BuyBitcoinResponse(url={}, opening_fee_params={})".format(self.url, self.opening_fee_params)

    def __eq__(self, other):
        if self.url != other.url:
            return False
        if self.opening_fee_params != other.opening_fee_params:
            return False
        return True

class FfiConverterTypeBuyBitcoinResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BuyBitcoinResponse(
            url=FfiConverterString.read(buf),
            opening_fee_params=FfiConverterOptionalTypeOpeningFeeParams.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.url, buf)
        FfiConverterOptionalTypeOpeningFeeParams.write(value.opening_fee_params, buf)


class CheckMessageRequest:

    def __init__(self, message, pubkey, signature):
        self.message = message
        self.pubkey = pubkey
        self.signature = signature

    def __str__(self):
        return "CheckMessageRequest(message={}, pubkey={}, signature={})".format(self.message, self.pubkey, self.signature)

    def __eq__(self, other):
        if self.message != other.message:
            return False
        if self.pubkey != other.pubkey:
            return False
        if self.signature != other.signature:
            return False
        return True

class FfiConverterTypeCheckMessageRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CheckMessageRequest(
            message=FfiConverterString.read(buf),
            pubkey=FfiConverterString.read(buf),
            signature=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.message, buf)
        FfiConverterString.write(value.pubkey, buf)
        FfiConverterString.write(value.signature, buf)


class CheckMessageResponse:

    def __init__(self, is_valid):
        self.is_valid = is_valid

    def __str__(self):
        return "CheckMessageResponse(is_valid={})".format(self.is_valid)

    def __eq__(self, other):
        if self.is_valid != other.is_valid:
            return False
        return True

class FfiConverterTypeCheckMessageResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CheckMessageResponse(
            is_valid=FfiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterBool.write(value.is_valid, buf)


class ClosedChannelPaymentDetails:

    def __init__(self, short_channel_id, state, funding_txid):
        self.short_channel_id = short_channel_id
        self.state = state
        self.funding_txid = funding_txid

    def __str__(self):
        return "ClosedChannelPaymentDetails(short_channel_id={}, state={}, funding_txid={})".format(self.short_channel_id, self.state, self.funding_txid)

    def __eq__(self, other):
        if self.short_channel_id != other.short_channel_id:
            return False
        if self.state != other.state:
            return False
        if self.funding_txid != other.funding_txid:
            return False
        return True

class FfiConverterTypeClosedChannelPaymentDetails(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClosedChannelPaymentDetails(
            short_channel_id=FfiConverterString.read(buf),
            state=FfiConverterTypeChannelState.read(buf),
            funding_txid=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.short_channel_id, buf)
        FfiConverterTypeChannelState.write(value.state, buf)
        FfiConverterString.write(value.funding_txid, buf)


class Config:

    def __init__(self, breezserver, mempoolspace_url, working_dir, network, payment_timeout_sec, default_lsp_id, api_key, maxfee_percent, node_config):
        self.breezserver = breezserver
        self.mempoolspace_url = mempoolspace_url
        self.working_dir = working_dir
        self.network = network
        self.payment_timeout_sec = payment_timeout_sec
        self.default_lsp_id = default_lsp_id
        self.api_key = api_key
        self.maxfee_percent = maxfee_percent
        self.node_config = node_config

    def __str__(self):
        return "Config(breezserver={}, mempoolspace_url={}, working_dir={}, network={}, payment_timeout_sec={}, default_lsp_id={}, api_key={}, maxfee_percent={}, node_config={})".format(self.breezserver, self.mempoolspace_url, self.working_dir, self.network, self.payment_timeout_sec, self.default_lsp_id, self.api_key, self.maxfee_percent, self.node_config)

    def __eq__(self, other):
        if self.breezserver != other.breezserver:
            return False
        if self.mempoolspace_url != other.mempoolspace_url:
            return False
        if self.working_dir != other.working_dir:
            return False
        if self.network != other.network:
            return False
        if self.payment_timeout_sec != other.payment_timeout_sec:
            return False
        if self.default_lsp_id != other.default_lsp_id:
            return False
        if self.api_key != other.api_key:
            return False
        if self.maxfee_percent != other.maxfee_percent:
            return False
        if self.node_config != other.node_config:
            return False
        return True

class FfiConverterTypeConfig(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Config(
            breezserver=FfiConverterString.read(buf),
            mempoolspace_url=FfiConverterString.read(buf),
            working_dir=FfiConverterString.read(buf),
            network=FfiConverterTypeNetwork.read(buf),
            payment_timeout_sec=FfiConverterUInt32.read(buf),
            default_lsp_id=FfiConverterOptionalString.read(buf),
            api_key=FfiConverterOptionalString.read(buf),
            maxfee_percent=FfiConverterDouble.read(buf),
            node_config=FfiConverterTypeNodeConfig.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.breezserver, buf)
        FfiConverterString.write(value.mempoolspace_url, buf)
        FfiConverterString.write(value.working_dir, buf)
        FfiConverterTypeNetwork.write(value.network, buf)
        FfiConverterUInt32.write(value.payment_timeout_sec, buf)
        FfiConverterOptionalString.write(value.default_lsp_id, buf)
        FfiConverterOptionalString.write(value.api_key, buf)
        FfiConverterDouble.write(value.maxfee_percent, buf)
        FfiConverterTypeNodeConfig.write(value.node_config, buf)


class CurrencyInfo:

    def __init__(self, name, fraction_size, spacing, symbol, uniq_symbol, localized_name, locale_overrides):
        self.name = name
        self.fraction_size = fraction_size
        self.spacing = spacing
        self.symbol = symbol
        self.uniq_symbol = uniq_symbol
        self.localized_name = localized_name
        self.locale_overrides = locale_overrides

    def __str__(self):
        return "CurrencyInfo(name={}, fraction_size={}, spacing={}, symbol={}, uniq_symbol={}, localized_name={}, locale_overrides={})".format(self.name, self.fraction_size, self.spacing, self.symbol, self.uniq_symbol, self.localized_name, self.locale_overrides)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.fraction_size != other.fraction_size:
            return False
        if self.spacing != other.spacing:
            return False
        if self.symbol != other.symbol:
            return False
        if self.uniq_symbol != other.uniq_symbol:
            return False
        if self.localized_name != other.localized_name:
            return False
        if self.locale_overrides != other.locale_overrides:
            return False
        return True

class FfiConverterTypeCurrencyInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CurrencyInfo(
            name=FfiConverterString.read(buf),
            fraction_size=FfiConverterUInt32.read(buf),
            spacing=FfiConverterOptionalUInt32.read(buf),
            symbol=FfiConverterOptionalTypeSymbol.read(buf),
            uniq_symbol=FfiConverterOptionalTypeSymbol.read(buf),
            localized_name=FfiConverterOptionalSequenceTypeLocalizedName.read(buf),
            locale_overrides=FfiConverterOptionalSequenceTypeLocaleOverrides.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.name, buf)
        FfiConverterUInt32.write(value.fraction_size, buf)
        FfiConverterOptionalUInt32.write(value.spacing, buf)
        FfiConverterOptionalTypeSymbol.write(value.symbol, buf)
        FfiConverterOptionalTypeSymbol.write(value.uniq_symbol, buf)
        FfiConverterOptionalSequenceTypeLocalizedName.write(value.localized_name, buf)
        FfiConverterOptionalSequenceTypeLocaleOverrides.write(value.locale_overrides, buf)


class FiatCurrency:

    def __init__(self, id, info):
        self.id = id
        self.info = info

    def __str__(self):
        return "FiatCurrency(id={}, info={})".format(self.id, self.info)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.info != other.info:
            return False
        return True

class FfiConverterTypeFiatCurrency(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FiatCurrency(
            id=FfiConverterString.read(buf),
            info=FfiConverterTypeCurrencyInfo.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.id, buf)
        FfiConverterTypeCurrencyInfo.write(value.info, buf)


class GreenlightCredentials:

    def __init__(self, device_key, device_cert):
        self.device_key = device_key
        self.device_cert = device_cert

    def __str__(self):
        return "GreenlightCredentials(device_key={}, device_cert={})".format(self.device_key, self.device_cert)

    def __eq__(self, other):
        if self.device_key != other.device_key:
            return False
        if self.device_cert != other.device_cert:
            return False
        return True

class FfiConverterTypeGreenlightCredentials(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GreenlightCredentials(
            device_key=FfiConverterSequenceUInt8.read(buf),
            device_cert=FfiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterSequenceUInt8.write(value.device_key, buf)
        FfiConverterSequenceUInt8.write(value.device_cert, buf)


class GreenlightNodeConfig:

    def __init__(self, partner_credentials, invite_code):
        self.partner_credentials = partner_credentials
        self.invite_code = invite_code

    def __str__(self):
        return "GreenlightNodeConfig(partner_credentials={}, invite_code={})".format(self.partner_credentials, self.invite_code)

    def __eq__(self, other):
        if self.partner_credentials != other.partner_credentials:
            return False
        if self.invite_code != other.invite_code:
            return False
        return True

class FfiConverterTypeGreenlightNodeConfig(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GreenlightNodeConfig(
            partner_credentials=FfiConverterOptionalTypeGreenlightCredentials.read(buf),
            invite_code=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalTypeGreenlightCredentials.write(value.partner_credentials, buf)
        FfiConverterOptionalString.write(value.invite_code, buf)


class InvoicePaidDetails:

    def __init__(self, payment_hash, bolt11):
        self.payment_hash = payment_hash
        self.bolt11 = bolt11

    def __str__(self):
        return "InvoicePaidDetails(payment_hash={}, bolt11={})".format(self.payment_hash, self.bolt11)

    def __eq__(self, other):
        if self.payment_hash != other.payment_hash:
            return False
        if self.bolt11 != other.bolt11:
            return False
        return True

class FfiConverterTypeInvoicePaidDetails(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return InvoicePaidDetails(
            payment_hash=FfiConverterString.read(buf),
            bolt11=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.payment_hash, buf)
        FfiConverterString.write(value.bolt11, buf)


class LnInvoice:

    def __init__(self, bolt11, payee_pubkey, payment_hash, description, description_hash, amount_msat, timestamp, expiry, routing_hints, payment_secret):
        self.bolt11 = bolt11
        self.payee_pubkey = payee_pubkey
        self.payment_hash = payment_hash
        self.description = description
        self.description_hash = description_hash
        self.amount_msat = amount_msat
        self.timestamp = timestamp
        self.expiry = expiry
        self.routing_hints = routing_hints
        self.payment_secret = payment_secret

    def __str__(self):
        return "LnInvoice(bolt11={}, payee_pubkey={}, payment_hash={}, description={}, description_hash={}, amount_msat={}, timestamp={}, expiry={}, routing_hints={}, payment_secret={})".format(self.bolt11, self.payee_pubkey, self.payment_hash, self.description, self.description_hash, self.amount_msat, self.timestamp, self.expiry, self.routing_hints, self.payment_secret)

    def __eq__(self, other):
        if self.bolt11 != other.bolt11:
            return False
        if self.payee_pubkey != other.payee_pubkey:
            return False
        if self.payment_hash != other.payment_hash:
            return False
        if self.description != other.description:
            return False
        if self.description_hash != other.description_hash:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.timestamp != other.timestamp:
            return False
        if self.expiry != other.expiry:
            return False
        if self.routing_hints != other.routing_hints:
            return False
        if self.payment_secret != other.payment_secret:
            return False
        return True

class FfiConverterTypeLnInvoice(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnInvoice(
            bolt11=FfiConverterString.read(buf),
            payee_pubkey=FfiConverterString.read(buf),
            payment_hash=FfiConverterString.read(buf),
            description=FfiConverterOptionalString.read(buf),
            description_hash=FfiConverterOptionalString.read(buf),
            amount_msat=FfiConverterOptionalUInt64.read(buf),
            timestamp=FfiConverterUInt64.read(buf),
            expiry=FfiConverterUInt64.read(buf),
            routing_hints=FfiConverterSequenceTypeRouteHint.read(buf),
            payment_secret=FfiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.bolt11, buf)
        FfiConverterString.write(value.payee_pubkey, buf)
        FfiConverterString.write(value.payment_hash, buf)
        FfiConverterOptionalString.write(value.description, buf)
        FfiConverterOptionalString.write(value.description_hash, buf)
        FfiConverterOptionalUInt64.write(value.amount_msat, buf)
        FfiConverterUInt64.write(value.timestamp, buf)
        FfiConverterUInt64.write(value.expiry, buf)
        FfiConverterSequenceTypeRouteHint.write(value.routing_hints, buf)
        FfiConverterSequenceUInt8.write(value.payment_secret, buf)


class LnPaymentDetails:

    def __init__(self, payment_hash, label, destination_pubkey, payment_preimage, keysend, bolt11, lnurl_success_action, lnurl_metadata, ln_address):
        self.payment_hash = payment_hash
        self.label = label
        self.destination_pubkey = destination_pubkey
        self.payment_preimage = payment_preimage
        self.keysend = keysend
        self.bolt11 = bolt11
        self.lnurl_success_action = lnurl_success_action
        self.lnurl_metadata = lnurl_metadata
        self.ln_address = ln_address

    def __str__(self):
        return "LnPaymentDetails(payment_hash={}, label={}, destination_pubkey={}, payment_preimage={}, keysend={}, bolt11={}, lnurl_success_action={}, lnurl_metadata={}, ln_address={})".format(self.payment_hash, self.label, self.destination_pubkey, self.payment_preimage, self.keysend, self.bolt11, self.lnurl_success_action, self.lnurl_metadata, self.ln_address)

    def __eq__(self, other):
        if self.payment_hash != other.payment_hash:
            return False
        if self.label != other.label:
            return False
        if self.destination_pubkey != other.destination_pubkey:
            return False
        if self.payment_preimage != other.payment_preimage:
            return False
        if self.keysend != other.keysend:
            return False
        if self.bolt11 != other.bolt11:
            return False
        if self.lnurl_success_action != other.lnurl_success_action:
            return False
        if self.lnurl_metadata != other.lnurl_metadata:
            return False
        if self.ln_address != other.ln_address:
            return False
        return True

class FfiConverterTypeLnPaymentDetails(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnPaymentDetails(
            payment_hash=FfiConverterString.read(buf),
            label=FfiConverterString.read(buf),
            destination_pubkey=FfiConverterString.read(buf),
            payment_preimage=FfiConverterString.read(buf),
            keysend=FfiConverterBool.read(buf),
            bolt11=FfiConverterString.read(buf),
            lnurl_success_action=FfiConverterOptionalTypeSuccessActionProcessed.read(buf),
            lnurl_metadata=FfiConverterOptionalString.read(buf),
            ln_address=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.payment_hash, buf)
        FfiConverterString.write(value.label, buf)
        FfiConverterString.write(value.destination_pubkey, buf)
        FfiConverterString.write(value.payment_preimage, buf)
        FfiConverterBool.write(value.keysend, buf)
        FfiConverterString.write(value.bolt11, buf)
        FfiConverterOptionalTypeSuccessActionProcessed.write(value.lnurl_success_action, buf)
        FfiConverterOptionalString.write(value.lnurl_metadata, buf)
        FfiConverterOptionalString.write(value.ln_address, buf)


class LnUrlAuthRequestData:

    def __init__(self, k1, action, domain, url):
        self.k1 = k1
        self.action = action
        self.domain = domain
        self.url = url

    def __str__(self):
        return "LnUrlAuthRequestData(k1={}, action={}, domain={}, url={})".format(self.k1, self.action, self.domain, self.url)

    def __eq__(self, other):
        if self.k1 != other.k1:
            return False
        if self.action != other.action:
            return False
        if self.domain != other.domain:
            return False
        if self.url != other.url:
            return False
        return True

class FfiConverterTypeLnUrlAuthRequestData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlAuthRequestData(
            k1=FfiConverterString.read(buf),
            action=FfiConverterOptionalString.read(buf),
            domain=FfiConverterString.read(buf),
            url=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.k1, buf)
        FfiConverterOptionalString.write(value.action, buf)
        FfiConverterString.write(value.domain, buf)
        FfiConverterString.write(value.url, buf)


class LnUrlErrorData:

    def __init__(self, reason):
        self.reason = reason

    def __str__(self):
        return "LnUrlErrorData(reason={})".format(self.reason)

    def __eq__(self, other):
        if self.reason != other.reason:
            return False
        return True

class FfiConverterTypeLnUrlErrorData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlErrorData(
            reason=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.reason, buf)


class LnUrlPayRequestData:

    def __init__(self, callback, min_sendable, max_sendable, metadata_str, comment_allowed, domain, ln_address):
        self.callback = callback
        self.min_sendable = min_sendable
        self.max_sendable = max_sendable
        self.metadata_str = metadata_str
        self.comment_allowed = comment_allowed
        self.domain = domain
        self.ln_address = ln_address

    def __str__(self):
        return "LnUrlPayRequestData(callback={}, min_sendable={}, max_sendable={}, metadata_str={}, comment_allowed={}, domain={}, ln_address={})".format(self.callback, self.min_sendable, self.max_sendable, self.metadata_str, self.comment_allowed, self.domain, self.ln_address)

    def __eq__(self, other):
        if self.callback != other.callback:
            return False
        if self.min_sendable != other.min_sendable:
            return False
        if self.max_sendable != other.max_sendable:
            return False
        if self.metadata_str != other.metadata_str:
            return False
        if self.comment_allowed != other.comment_allowed:
            return False
        if self.domain != other.domain:
            return False
        if self.ln_address != other.ln_address:
            return False
        return True

class FfiConverterTypeLnUrlPayRequestData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlPayRequestData(
            callback=FfiConverterString.read(buf),
            min_sendable=FfiConverterUInt64.read(buf),
            max_sendable=FfiConverterUInt64.read(buf),
            metadata_str=FfiConverterString.read(buf),
            comment_allowed=FfiConverterUInt16.read(buf),
            domain=FfiConverterString.read(buf),
            ln_address=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.callback, buf)
        FfiConverterUInt64.write(value.min_sendable, buf)
        FfiConverterUInt64.write(value.max_sendable, buf)
        FfiConverterString.write(value.metadata_str, buf)
        FfiConverterUInt16.write(value.comment_allowed, buf)
        FfiConverterString.write(value.domain, buf)
        FfiConverterOptionalString.write(value.ln_address, buf)


class LnUrlWithdrawRequestData:

    def __init__(self, callback, k1, default_description, min_withdrawable, max_withdrawable):
        self.callback = callback
        self.k1 = k1
        self.default_description = default_description
        self.min_withdrawable = min_withdrawable
        self.max_withdrawable = max_withdrawable

    def __str__(self):
        return "LnUrlWithdrawRequestData(callback={}, k1={}, default_description={}, min_withdrawable={}, max_withdrawable={})".format(self.callback, self.k1, self.default_description, self.min_withdrawable, self.max_withdrawable)

    def __eq__(self, other):
        if self.callback != other.callback:
            return False
        if self.k1 != other.k1:
            return False
        if self.default_description != other.default_description:
            return False
        if self.min_withdrawable != other.min_withdrawable:
            return False
        if self.max_withdrawable != other.max_withdrawable:
            return False
        return True

class FfiConverterTypeLnUrlWithdrawRequestData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnUrlWithdrawRequestData(
            callback=FfiConverterString.read(buf),
            k1=FfiConverterString.read(buf),
            default_description=FfiConverterString.read(buf),
            min_withdrawable=FfiConverterUInt64.read(buf),
            max_withdrawable=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.callback, buf)
        FfiConverterString.write(value.k1, buf)
        FfiConverterString.write(value.default_description, buf)
        FfiConverterUInt64.write(value.min_withdrawable, buf)
        FfiConverterUInt64.write(value.max_withdrawable, buf)


class LocaleOverrides:

    def __init__(self, locale, spacing, symbol):
        self.locale = locale
        self.spacing = spacing
        self.symbol = symbol

    def __str__(self):
        return "LocaleOverrides(locale={}, spacing={}, symbol={})".format(self.locale, self.spacing, self.symbol)

    def __eq__(self, other):
        if self.locale != other.locale:
            return False
        if self.spacing != other.spacing:
            return False
        if self.symbol != other.symbol:
            return False
        return True

class FfiConverterTypeLocaleOverrides(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LocaleOverrides(
            locale=FfiConverterString.read(buf),
            spacing=FfiConverterOptionalUInt32.read(buf),
            symbol=FfiConverterTypeSymbol.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.locale, buf)
        FfiConverterOptionalUInt32.write(value.spacing, buf)
        FfiConverterTypeSymbol.write(value.symbol, buf)


class LocalizedName:

    def __init__(self, locale, name):
        self.locale = locale
        self.name = name

    def __str__(self):
        return "LocalizedName(locale={}, name={})".format(self.locale, self.name)

    def __eq__(self, other):
        if self.locale != other.locale:
            return False
        if self.name != other.name:
            return False
        return True

class FfiConverterTypeLocalizedName(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LocalizedName(
            locale=FfiConverterString.read(buf),
            name=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.locale, buf)
        FfiConverterString.write(value.name, buf)


class LogEntry:

    def __init__(self, line, level):
        self.line = line
        self.level = level

    def __str__(self):
        return "LogEntry(line={}, level={})".format(self.line, self.level)

    def __eq__(self, other):
        if self.line != other.line:
            return False
        if self.level != other.level:
            return False
        return True

class FfiConverterTypeLogEntry(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LogEntry(
            line=FfiConverterString.read(buf),
            level=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.line, buf)
        FfiConverterString.write(value.level, buf)


class LspInformation:

    def __init__(self, id, name, widget_url, pubkey, host, channel_capacity, target_conf, base_fee_msat, fee_rate, time_lock_delta, min_htlc_msat, lsp_pubkey, opening_fee_params_list):
        self.id = id
        self.name = name
        self.widget_url = widget_url
        self.pubkey = pubkey
        self.host = host
        self.channel_capacity = channel_capacity
        self.target_conf = target_conf
        self.base_fee_msat = base_fee_msat
        self.fee_rate = fee_rate
        self.time_lock_delta = time_lock_delta
        self.min_htlc_msat = min_htlc_msat
        self.lsp_pubkey = lsp_pubkey
        self.opening_fee_params_list = opening_fee_params_list

    def __str__(self):
        return "LspInformation(id={}, name={}, widget_url={}, pubkey={}, host={}, channel_capacity={}, target_conf={}, base_fee_msat={}, fee_rate={}, time_lock_delta={}, min_htlc_msat={}, lsp_pubkey={}, opening_fee_params_list={})".format(self.id, self.name, self.widget_url, self.pubkey, self.host, self.channel_capacity, self.target_conf, self.base_fee_msat, self.fee_rate, self.time_lock_delta, self.min_htlc_msat, self.lsp_pubkey, self.opening_fee_params_list)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.name != other.name:
            return False
        if self.widget_url != other.widget_url:
            return False
        if self.pubkey != other.pubkey:
            return False
        if self.host != other.host:
            return False
        if self.channel_capacity != other.channel_capacity:
            return False
        if self.target_conf != other.target_conf:
            return False
        if self.base_fee_msat != other.base_fee_msat:
            return False
        if self.fee_rate != other.fee_rate:
            return False
        if self.time_lock_delta != other.time_lock_delta:
            return False
        if self.min_htlc_msat != other.min_htlc_msat:
            return False
        if self.lsp_pubkey != other.lsp_pubkey:
            return False
        if self.opening_fee_params_list != other.opening_fee_params_list:
            return False
        return True

class FfiConverterTypeLspInformation(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LspInformation(
            id=FfiConverterString.read(buf),
            name=FfiConverterString.read(buf),
            widget_url=FfiConverterString.read(buf),
            pubkey=FfiConverterString.read(buf),
            host=FfiConverterString.read(buf),
            channel_capacity=FfiConverterInt64.read(buf),
            target_conf=FfiConverterInt32.read(buf),
            base_fee_msat=FfiConverterInt64.read(buf),
            fee_rate=FfiConverterDouble.read(buf),
            time_lock_delta=FfiConverterUInt32.read(buf),
            min_htlc_msat=FfiConverterInt64.read(buf),
            lsp_pubkey=FfiConverterSequenceUInt8.read(buf),
            opening_fee_params_list=FfiConverterTypeOpeningFeeParamsMenu.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.id, buf)
        FfiConverterString.write(value.name, buf)
        FfiConverterString.write(value.widget_url, buf)
        FfiConverterString.write(value.pubkey, buf)
        FfiConverterString.write(value.host, buf)
        FfiConverterInt64.write(value.channel_capacity, buf)
        FfiConverterInt32.write(value.target_conf, buf)
        FfiConverterInt64.write(value.base_fee_msat, buf)
        FfiConverterDouble.write(value.fee_rate, buf)
        FfiConverterUInt32.write(value.time_lock_delta, buf)
        FfiConverterInt64.write(value.min_htlc_msat, buf)
        FfiConverterSequenceUInt8.write(value.lsp_pubkey, buf)
        FfiConverterTypeOpeningFeeParamsMenu.write(value.opening_fee_params_list, buf)


class MessageSuccessActionData:

    def __init__(self, message):
        self.message = message

    def __str__(self):
        return "MessageSuccessActionData(message={})".format(self.message)

    def __eq__(self, other):
        if self.message != other.message:
            return False
        return True

class FfiConverterTypeMessageSuccessActionData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MessageSuccessActionData(
            message=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.message, buf)


class MetadataItem:

    def __init__(self, key, value):
        self.key = key
        self.value = value

    def __str__(self):
        return "MetadataItem(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True

class FfiConverterTypeMetadataItem(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MetadataItem(
            key=FfiConverterString.read(buf),
            value=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.key, buf)
        FfiConverterString.write(value.value, buf)


class NodeState:

    def __init__(self, id, block_height, channels_balance_msat, onchain_balance_msat, utxos, max_payable_msat, max_receivable_msat, max_single_payment_amount_msat, max_chan_reserve_msats, connected_peers, inbound_liquidity_msats):
        self.id = id
        self.block_height = block_height
        self.channels_balance_msat = channels_balance_msat
        self.onchain_balance_msat = onchain_balance_msat
        self.utxos = utxos
        self.max_payable_msat = max_payable_msat
        self.max_receivable_msat = max_receivable_msat
        self.max_single_payment_amount_msat = max_single_payment_amount_msat
        self.max_chan_reserve_msats = max_chan_reserve_msats
        self.connected_peers = connected_peers
        self.inbound_liquidity_msats = inbound_liquidity_msats

    def __str__(self):
        return "NodeState(id={}, block_height={}, channels_balance_msat={}, onchain_balance_msat={}, utxos={}, max_payable_msat={}, max_receivable_msat={}, max_single_payment_amount_msat={}, max_chan_reserve_msats={}, connected_peers={}, inbound_liquidity_msats={})".format(self.id, self.block_height, self.channels_balance_msat, self.onchain_balance_msat, self.utxos, self.max_payable_msat, self.max_receivable_msat, self.max_single_payment_amount_msat, self.max_chan_reserve_msats, self.connected_peers, self.inbound_liquidity_msats)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.block_height != other.block_height:
            return False
        if self.channels_balance_msat != other.channels_balance_msat:
            return False
        if self.onchain_balance_msat != other.onchain_balance_msat:
            return False
        if self.utxos != other.utxos:
            return False
        if self.max_payable_msat != other.max_payable_msat:
            return False
        if self.max_receivable_msat != other.max_receivable_msat:
            return False
        if self.max_single_payment_amount_msat != other.max_single_payment_amount_msat:
            return False
        if self.max_chan_reserve_msats != other.max_chan_reserve_msats:
            return False
        if self.connected_peers != other.connected_peers:
            return False
        if self.inbound_liquidity_msats != other.inbound_liquidity_msats:
            return False
        return True

class FfiConverterTypeNodeState(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NodeState(
            id=FfiConverterString.read(buf),
            block_height=FfiConverterUInt32.read(buf),
            channels_balance_msat=FfiConverterUInt64.read(buf),
            onchain_balance_msat=FfiConverterUInt64.read(buf),
            utxos=FfiConverterSequenceTypeUnspentTransactionOutput.read(buf),
            max_payable_msat=FfiConverterUInt64.read(buf),
            max_receivable_msat=FfiConverterUInt64.read(buf),
            max_single_payment_amount_msat=FfiConverterUInt64.read(buf),
            max_chan_reserve_msats=FfiConverterUInt64.read(buf),
            connected_peers=FfiConverterSequenceString.read(buf),
            inbound_liquidity_msats=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.id, buf)
        FfiConverterUInt32.write(value.block_height, buf)
        FfiConverterUInt64.write(value.channels_balance_msat, buf)
        FfiConverterUInt64.write(value.onchain_balance_msat, buf)
        FfiConverterSequenceTypeUnspentTransactionOutput.write(value.utxos, buf)
        FfiConverterUInt64.write(value.max_payable_msat, buf)
        FfiConverterUInt64.write(value.max_receivable_msat, buf)
        FfiConverterUInt64.write(value.max_single_payment_amount_msat, buf)
        FfiConverterUInt64.write(value.max_chan_reserve_msats, buf)
        FfiConverterSequenceString.write(value.connected_peers, buf)
        FfiConverterUInt64.write(value.inbound_liquidity_msats, buf)


class OpeningFeeParams:

    def __init__(self, min_msat, proportional, valid_until, max_idle_time, max_client_to_self_delay, promise):
        self.min_msat = min_msat
        self.proportional = proportional
        self.valid_until = valid_until
        self.max_idle_time = max_idle_time
        self.max_client_to_self_delay = max_client_to_self_delay
        self.promise = promise

    def __str__(self):
        return "OpeningFeeParams(min_msat={}, proportional={}, valid_until={}, max_idle_time={}, max_client_to_self_delay={}, promise={})".format(self.min_msat, self.proportional, self.valid_until, self.max_idle_time, self.max_client_to_self_delay, self.promise)

    def __eq__(self, other):
        if self.min_msat != other.min_msat:
            return False
        if self.proportional != other.proportional:
            return False
        if self.valid_until != other.valid_until:
            return False
        if self.max_idle_time != other.max_idle_time:
            return False
        if self.max_client_to_self_delay != other.max_client_to_self_delay:
            return False
        if self.promise != other.promise:
            return False
        return True

class FfiConverterTypeOpeningFeeParams(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OpeningFeeParams(
            min_msat=FfiConverterUInt64.read(buf),
            proportional=FfiConverterUInt32.read(buf),
            valid_until=FfiConverterString.read(buf),
            max_idle_time=FfiConverterUInt32.read(buf),
            max_client_to_self_delay=FfiConverterUInt32.read(buf),
            promise=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.min_msat, buf)
        FfiConverterUInt32.write(value.proportional, buf)
        FfiConverterString.write(value.valid_until, buf)
        FfiConverterUInt32.write(value.max_idle_time, buf)
        FfiConverterUInt32.write(value.max_client_to_self_delay, buf)
        FfiConverterString.write(value.promise, buf)


class OpeningFeeParamsMenu:

    def __init__(self, values):
        self.values = values

    def __str__(self):
        return "OpeningFeeParamsMenu(values={})".format(self.values)

    def __eq__(self, other):
        if self.values != other.values:
            return False
        return True

class FfiConverterTypeOpeningFeeParamsMenu(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OpeningFeeParamsMenu(
            values=FfiConverterSequenceTypeOpeningFeeParams.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterSequenceTypeOpeningFeeParams.write(value.values, buf)


class Payment:

    def __init__(self, id, payment_type, payment_time, amount_msat, fee_msat, pending, description, details):
        self.id = id
        self.payment_type = payment_type
        self.payment_time = payment_time
        self.amount_msat = amount_msat
        self.fee_msat = fee_msat
        self.pending = pending
        self.description = description
        self.details = details

    def __str__(self):
        return "Payment(id={}, payment_type={}, payment_time={}, amount_msat={}, fee_msat={}, pending={}, description={}, details={})".format(self.id, self.payment_type, self.payment_time, self.amount_msat, self.fee_msat, self.pending, self.description, self.details)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.payment_type != other.payment_type:
            return False
        if self.payment_time != other.payment_time:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.fee_msat != other.fee_msat:
            return False
        if self.pending != other.pending:
            return False
        if self.description != other.description:
            return False
        if self.details != other.details:
            return False
        return True

class FfiConverterTypePayment(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Payment(
            id=FfiConverterString.read(buf),
            payment_type=FfiConverterTypePaymentType.read(buf),
            payment_time=FfiConverterInt64.read(buf),
            amount_msat=FfiConverterUInt64.read(buf),
            fee_msat=FfiConverterUInt64.read(buf),
            pending=FfiConverterBool.read(buf),
            description=FfiConverterOptionalString.read(buf),
            details=FfiConverterTypePaymentDetails.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.id, buf)
        FfiConverterTypePaymentType.write(value.payment_type, buf)
        FfiConverterInt64.write(value.payment_time, buf)
        FfiConverterUInt64.write(value.amount_msat, buf)
        FfiConverterUInt64.write(value.fee_msat, buf)
        FfiConverterBool.write(value.pending, buf)
        FfiConverterOptionalString.write(value.description, buf)
        FfiConverterTypePaymentDetails.write(value.details, buf)


class PaymentFailedData:

    def __init__(self, error, node_id, invoice):
        self.error = error
        self.node_id = node_id
        self.invoice = invoice

    def __str__(self):
        return "PaymentFailedData(error={}, node_id={}, invoice={})".format(self.error, self.node_id, self.invoice)

    def __eq__(self, other):
        if self.error != other.error:
            return False
        if self.node_id != other.node_id:
            return False
        if self.invoice != other.invoice:
            return False
        return True

class FfiConverterTypePaymentFailedData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PaymentFailedData(
            error=FfiConverterString.read(buf),
            node_id=FfiConverterString.read(buf),
            invoice=FfiConverterOptionalTypeLnInvoice.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.error, buf)
        FfiConverterString.write(value.node_id, buf)
        FfiConverterOptionalTypeLnInvoice.write(value.invoice, buf)


class Rate:

    def __init__(self, coin, value):
        self.coin = coin
        self.value = value

    def __str__(self):
        return "Rate(coin={}, value={})".format(self.coin, self.value)

    def __eq__(self, other):
        if self.coin != other.coin:
            return False
        if self.value != other.value:
            return False
        return True

class FfiConverterTypeRate(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Rate(
            coin=FfiConverterString.read(buf),
            value=FfiConverterDouble.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.coin, buf)
        FfiConverterDouble.write(value.value, buf)


class ReceiveOnchainRequest:

    def __init__(self, opening_fee_params):
        self.opening_fee_params = opening_fee_params

    def __str__(self):
        return "ReceiveOnchainRequest(opening_fee_params={})".format(self.opening_fee_params)

    def __eq__(self, other):
        if self.opening_fee_params != other.opening_fee_params:
            return False
        return True

class FfiConverterTypeReceiveOnchainRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReceiveOnchainRequest(
            opening_fee_params=FfiConverterOptionalTypeOpeningFeeParams.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalTypeOpeningFeeParams.write(value.opening_fee_params, buf)


class ReceivePaymentRequest:

    def __init__(self, amount_sats, description, preimage, opening_fee_params):
        self.amount_sats = amount_sats
        self.description = description
        self.preimage = preimage
        self.opening_fee_params = opening_fee_params

    def __str__(self):
        return "ReceivePaymentRequest(amount_sats={}, description={}, preimage={}, opening_fee_params={})".format(self.amount_sats, self.description, self.preimage, self.opening_fee_params)

    def __eq__(self, other):
        if self.amount_sats != other.amount_sats:
            return False
        if self.description != other.description:
            return False
        if self.preimage != other.preimage:
            return False
        if self.opening_fee_params != other.opening_fee_params:
            return False
        return True

class FfiConverterTypeReceivePaymentRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReceivePaymentRequest(
            amount_sats=FfiConverterUInt64.read(buf),
            description=FfiConverterString.read(buf),
            preimage=FfiConverterOptionalSequenceUInt8.read(buf),
            opening_fee_params=FfiConverterOptionalTypeOpeningFeeParams.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.amount_sats, buf)
        FfiConverterString.write(value.description, buf)
        FfiConverterOptionalSequenceUInt8.write(value.preimage, buf)
        FfiConverterOptionalTypeOpeningFeeParams.write(value.opening_fee_params, buf)


class ReceivePaymentResponse:

    def __init__(self, ln_invoice, opening_fee_params, opening_fee_msat):
        self.ln_invoice = ln_invoice
        self.opening_fee_params = opening_fee_params
        self.opening_fee_msat = opening_fee_msat

    def __str__(self):
        return "ReceivePaymentResponse(ln_invoice={}, opening_fee_params={}, opening_fee_msat={})".format(self.ln_invoice, self.opening_fee_params, self.opening_fee_msat)

    def __eq__(self, other):
        if self.ln_invoice != other.ln_invoice:
            return False
        if self.opening_fee_params != other.opening_fee_params:
            return False
        if self.opening_fee_msat != other.opening_fee_msat:
            return False
        return True

class FfiConverterTypeReceivePaymentResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReceivePaymentResponse(
            ln_invoice=FfiConverterTypeLnInvoice.read(buf),
            opening_fee_params=FfiConverterOptionalTypeOpeningFeeParams.read(buf),
            opening_fee_msat=FfiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeLnInvoice.write(value.ln_invoice, buf)
        FfiConverterOptionalTypeOpeningFeeParams.write(value.opening_fee_params, buf)
        FfiConverterOptionalUInt64.write(value.opening_fee_msat, buf)


class RecommendedFees:

    def __init__(self, fastest_fee, half_hour_fee, hour_fee, economy_fee, minimum_fee):
        self.fastest_fee = fastest_fee
        self.half_hour_fee = half_hour_fee
        self.hour_fee = hour_fee
        self.economy_fee = economy_fee
        self.minimum_fee = minimum_fee

    def __str__(self):
        return "RecommendedFees(fastest_fee={}, half_hour_fee={}, hour_fee={}, economy_fee={}, minimum_fee={})".format(self.fastest_fee, self.half_hour_fee, self.hour_fee, self.economy_fee, self.minimum_fee)

    def __eq__(self, other):
        if self.fastest_fee != other.fastest_fee:
            return False
        if self.half_hour_fee != other.half_hour_fee:
            return False
        if self.hour_fee != other.hour_fee:
            return False
        if self.economy_fee != other.economy_fee:
            return False
        if self.minimum_fee != other.minimum_fee:
            return False
        return True

class FfiConverterTypeRecommendedFees(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RecommendedFees(
            fastest_fee=FfiConverterUInt64.read(buf),
            half_hour_fee=FfiConverterUInt64.read(buf),
            hour_fee=FfiConverterUInt64.read(buf),
            economy_fee=FfiConverterUInt64.read(buf),
            minimum_fee=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.fastest_fee, buf)
        FfiConverterUInt64.write(value.half_hour_fee, buf)
        FfiConverterUInt64.write(value.hour_fee, buf)
        FfiConverterUInt64.write(value.economy_fee, buf)
        FfiConverterUInt64.write(value.minimum_fee, buf)


class ReverseSwapFeesRequest:

    def __init__(self, send_amount_sat):
        self.send_amount_sat = send_amount_sat

    def __str__(self):
        return "ReverseSwapFeesRequest(send_amount_sat={})".format(self.send_amount_sat)

    def __eq__(self, other):
        if self.send_amount_sat != other.send_amount_sat:
            return False
        return True

class FfiConverterTypeReverseSwapFeesRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReverseSwapFeesRequest(
            send_amount_sat=FfiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalUInt64.write(value.send_amount_sat, buf)


class ReverseSwapInfo:

    def __init__(self, id, claim_pubkey, onchain_amount_sat, status):
        self.id = id
        self.claim_pubkey = claim_pubkey
        self.onchain_amount_sat = onchain_amount_sat
        self.status = status

    def __str__(self):
        return "ReverseSwapInfo(id={}, claim_pubkey={}, onchain_amount_sat={}, status={})".format(self.id, self.claim_pubkey, self.onchain_amount_sat, self.status)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.claim_pubkey != other.claim_pubkey:
            return False
        if self.onchain_amount_sat != other.onchain_amount_sat:
            return False
        if self.status != other.status:
            return False
        return True

class FfiConverterTypeReverseSwapInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReverseSwapInfo(
            id=FfiConverterString.read(buf),
            claim_pubkey=FfiConverterString.read(buf),
            onchain_amount_sat=FfiConverterUInt64.read(buf),
            status=FfiConverterTypeReverseSwapStatus.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.id, buf)
        FfiConverterString.write(value.claim_pubkey, buf)
        FfiConverterUInt64.write(value.onchain_amount_sat, buf)
        FfiConverterTypeReverseSwapStatus.write(value.status, buf)


class ReverseSwapPairInfo:

    def __init__(self, min, max, fees_hash, fees_percentage, fees_lockup, fees_claim, total_estimated_fees):
        self.min = min
        self.max = max
        self.fees_hash = fees_hash
        self.fees_percentage = fees_percentage
        self.fees_lockup = fees_lockup
        self.fees_claim = fees_claim
        self.total_estimated_fees = total_estimated_fees

    def __str__(self):
        return "ReverseSwapPairInfo(min={}, max={}, fees_hash={}, fees_percentage={}, fees_lockup={}, fees_claim={}, total_estimated_fees={})".format(self.min, self.max, self.fees_hash, self.fees_percentage, self.fees_lockup, self.fees_claim, self.total_estimated_fees)

    def __eq__(self, other):
        if self.min != other.min:
            return False
        if self.max != other.max:
            return False
        if self.fees_hash != other.fees_hash:
            return False
        if self.fees_percentage != other.fees_percentage:
            return False
        if self.fees_lockup != other.fees_lockup:
            return False
        if self.fees_claim != other.fees_claim:
            return False
        if self.total_estimated_fees != other.total_estimated_fees:
            return False
        return True

class FfiConverterTypeReverseSwapPairInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReverseSwapPairInfo(
            min=FfiConverterUInt64.read(buf),
            max=FfiConverterUInt64.read(buf),
            fees_hash=FfiConverterString.read(buf),
            fees_percentage=FfiConverterDouble.read(buf),
            fees_lockup=FfiConverterUInt64.read(buf),
            fees_claim=FfiConverterUInt64.read(buf),
            total_estimated_fees=FfiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.min, buf)
        FfiConverterUInt64.write(value.max, buf)
        FfiConverterString.write(value.fees_hash, buf)
        FfiConverterDouble.write(value.fees_percentage, buf)
        FfiConverterUInt64.write(value.fees_lockup, buf)
        FfiConverterUInt64.write(value.fees_claim, buf)
        FfiConverterOptionalUInt64.write(value.total_estimated_fees, buf)


class RouteHint:

    def __init__(self, hops):
        self.hops = hops

    def __str__(self):
        return "RouteHint(hops={})".format(self.hops)

    def __eq__(self, other):
        if self.hops != other.hops:
            return False
        return True

class FfiConverterTypeRouteHint(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RouteHint(
            hops=FfiConverterSequenceTypeRouteHintHop.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterSequenceTypeRouteHintHop.write(value.hops, buf)


class RouteHintHop:

    def __init__(self, src_node_id, short_channel_id, fees_base_msat, fees_proportional_millionths, cltv_expiry_delta, htlc_minimum_msat, htlc_maximum_msat):
        self.src_node_id = src_node_id
        self.short_channel_id = short_channel_id
        self.fees_base_msat = fees_base_msat
        self.fees_proportional_millionths = fees_proportional_millionths
        self.cltv_expiry_delta = cltv_expiry_delta
        self.htlc_minimum_msat = htlc_minimum_msat
        self.htlc_maximum_msat = htlc_maximum_msat

    def __str__(self):
        return "RouteHintHop(src_node_id={}, short_channel_id={}, fees_base_msat={}, fees_proportional_millionths={}, cltv_expiry_delta={}, htlc_minimum_msat={}, htlc_maximum_msat={})".format(self.src_node_id, self.short_channel_id, self.fees_base_msat, self.fees_proportional_millionths, self.cltv_expiry_delta, self.htlc_minimum_msat, self.htlc_maximum_msat)

    def __eq__(self, other):
        if self.src_node_id != other.src_node_id:
            return False
        if self.short_channel_id != other.short_channel_id:
            return False
        if self.fees_base_msat != other.fees_base_msat:
            return False
        if self.fees_proportional_millionths != other.fees_proportional_millionths:
            return False
        if self.cltv_expiry_delta != other.cltv_expiry_delta:
            return False
        if self.htlc_minimum_msat != other.htlc_minimum_msat:
            return False
        if self.htlc_maximum_msat != other.htlc_maximum_msat:
            return False
        return True

class FfiConverterTypeRouteHintHop(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RouteHintHop(
            src_node_id=FfiConverterString.read(buf),
            short_channel_id=FfiConverterUInt64.read(buf),
            fees_base_msat=FfiConverterUInt32.read(buf),
            fees_proportional_millionths=FfiConverterUInt32.read(buf),
            cltv_expiry_delta=FfiConverterUInt64.read(buf),
            htlc_minimum_msat=FfiConverterOptionalUInt64.read(buf),
            htlc_maximum_msat=FfiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.src_node_id, buf)
        FfiConverterUInt64.write(value.short_channel_id, buf)
        FfiConverterUInt32.write(value.fees_base_msat, buf)
        FfiConverterUInt32.write(value.fees_proportional_millionths, buf)
        FfiConverterUInt64.write(value.cltv_expiry_delta, buf)
        FfiConverterOptionalUInt64.write(value.htlc_minimum_msat, buf)
        FfiConverterOptionalUInt64.write(value.htlc_maximum_msat, buf)


class SignMessageRequest:

    def __init__(self, message):
        self.message = message

    def __str__(self):
        return "SignMessageRequest(message={})".format(self.message)

    def __eq__(self, other):
        if self.message != other.message:
            return False
        return True

class FfiConverterTypeSignMessageRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SignMessageRequest(
            message=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.message, buf)


class SignMessageResponse:

    def __init__(self, signature):
        self.signature = signature

    def __str__(self):
        return "SignMessageResponse(signature={})".format(self.signature)

    def __eq__(self, other):
        if self.signature != other.signature:
            return False
        return True

class FfiConverterTypeSignMessageResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SignMessageResponse(
            signature=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.signature, buf)


class SwapInfo:

    def __init__(self, bitcoin_address, created_at, lock_height, payment_hash, preimage, private_key, public_key, swapper_public_key, script, bolt11, paid_sats, unconfirmed_sats, confirmed_sats, status, refund_tx_ids, unconfirmed_tx_ids, confirmed_tx_ids, min_allowed_deposit, max_allowed_deposit, last_redeem_error, channel_opening_fees):
        self.bitcoin_address = bitcoin_address
        self.created_at = created_at
        self.lock_height = lock_height
        self.payment_hash = payment_hash
        self.preimage = preimage
        self.private_key = private_key
        self.public_key = public_key
        self.swapper_public_key = swapper_public_key
        self.script = script
        self.bolt11 = bolt11
        self.paid_sats = paid_sats
        self.unconfirmed_sats = unconfirmed_sats
        self.confirmed_sats = confirmed_sats
        self.status = status
        self.refund_tx_ids = refund_tx_ids
        self.unconfirmed_tx_ids = unconfirmed_tx_ids
        self.confirmed_tx_ids = confirmed_tx_ids
        self.min_allowed_deposit = min_allowed_deposit
        self.max_allowed_deposit = max_allowed_deposit
        self.last_redeem_error = last_redeem_error
        self.channel_opening_fees = channel_opening_fees

    def __str__(self):
        return "SwapInfo(bitcoin_address={}, created_at={}, lock_height={}, payment_hash={}, preimage={}, private_key={}, public_key={}, swapper_public_key={}, script={}, bolt11={}, paid_sats={}, unconfirmed_sats={}, confirmed_sats={}, status={}, refund_tx_ids={}, unconfirmed_tx_ids={}, confirmed_tx_ids={}, min_allowed_deposit={}, max_allowed_deposit={}, last_redeem_error={}, channel_opening_fees={})".format(self.bitcoin_address, self.created_at, self.lock_height, self.payment_hash, self.preimage, self.private_key, self.public_key, self.swapper_public_key, self.script, self.bolt11, self.paid_sats, self.unconfirmed_sats, self.confirmed_sats, self.status, self.refund_tx_ids, self.unconfirmed_tx_ids, self.confirmed_tx_ids, self.min_allowed_deposit, self.max_allowed_deposit, self.last_redeem_error, self.channel_opening_fees)

    def __eq__(self, other):
        if self.bitcoin_address != other.bitcoin_address:
            return False
        if self.created_at != other.created_at:
            return False
        if self.lock_height != other.lock_height:
            return False
        if self.payment_hash != other.payment_hash:
            return False
        if self.preimage != other.preimage:
            return False
        if self.private_key != other.private_key:
            return False
        if self.public_key != other.public_key:
            return False
        if self.swapper_public_key != other.swapper_public_key:
            return False
        if self.script != other.script:
            return False
        if self.bolt11 != other.bolt11:
            return False
        if self.paid_sats != other.paid_sats:
            return False
        if self.unconfirmed_sats != other.unconfirmed_sats:
            return False
        if self.confirmed_sats != other.confirmed_sats:
            return False
        if self.status != other.status:
            return False
        if self.refund_tx_ids != other.refund_tx_ids:
            return False
        if self.unconfirmed_tx_ids != other.unconfirmed_tx_ids:
            return False
        if self.confirmed_tx_ids != other.confirmed_tx_ids:
            return False
        if self.min_allowed_deposit != other.min_allowed_deposit:
            return False
        if self.max_allowed_deposit != other.max_allowed_deposit:
            return False
        if self.last_redeem_error != other.last_redeem_error:
            return False
        if self.channel_opening_fees != other.channel_opening_fees:
            return False
        return True

class FfiConverterTypeSwapInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SwapInfo(
            bitcoin_address=FfiConverterString.read(buf),
            created_at=FfiConverterInt64.read(buf),
            lock_height=FfiConverterInt64.read(buf),
            payment_hash=FfiConverterSequenceUInt8.read(buf),
            preimage=FfiConverterSequenceUInt8.read(buf),
            private_key=FfiConverterSequenceUInt8.read(buf),
            public_key=FfiConverterSequenceUInt8.read(buf),
            swapper_public_key=FfiConverterSequenceUInt8.read(buf),
            script=FfiConverterSequenceUInt8.read(buf),
            bolt11=FfiConverterOptionalString.read(buf),
            paid_sats=FfiConverterUInt64.read(buf),
            unconfirmed_sats=FfiConverterUInt64.read(buf),
            confirmed_sats=FfiConverterUInt64.read(buf),
            status=FfiConverterTypeSwapStatus.read(buf),
            refund_tx_ids=FfiConverterSequenceString.read(buf),
            unconfirmed_tx_ids=FfiConverterSequenceString.read(buf),
            confirmed_tx_ids=FfiConverterSequenceString.read(buf),
            min_allowed_deposit=FfiConverterInt64.read(buf),
            max_allowed_deposit=FfiConverterInt64.read(buf),
            last_redeem_error=FfiConverterOptionalString.read(buf),
            channel_opening_fees=FfiConverterOptionalTypeOpeningFeeParams.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.bitcoin_address, buf)
        FfiConverterInt64.write(value.created_at, buf)
        FfiConverterInt64.write(value.lock_height, buf)
        FfiConverterSequenceUInt8.write(value.payment_hash, buf)
        FfiConverterSequenceUInt8.write(value.preimage, buf)
        FfiConverterSequenceUInt8.write(value.private_key, buf)
        FfiConverterSequenceUInt8.write(value.public_key, buf)
        FfiConverterSequenceUInt8.write(value.swapper_public_key, buf)
        FfiConverterSequenceUInt8.write(value.script, buf)
        FfiConverterOptionalString.write(value.bolt11, buf)
        FfiConverterUInt64.write(value.paid_sats, buf)
        FfiConverterUInt64.write(value.unconfirmed_sats, buf)
        FfiConverterUInt64.write(value.confirmed_sats, buf)
        FfiConverterTypeSwapStatus.write(value.status, buf)
        FfiConverterSequenceString.write(value.refund_tx_ids, buf)
        FfiConverterSequenceString.write(value.unconfirmed_tx_ids, buf)
        FfiConverterSequenceString.write(value.confirmed_tx_ids, buf)
        FfiConverterInt64.write(value.min_allowed_deposit, buf)
        FfiConverterInt64.write(value.max_allowed_deposit, buf)
        FfiConverterOptionalString.write(value.last_redeem_error, buf)
        FfiConverterOptionalTypeOpeningFeeParams.write(value.channel_opening_fees, buf)


class Symbol:

    def __init__(self, grapheme, template, rtl, position):
        self.grapheme = grapheme
        self.template = template
        self.rtl = rtl
        self.position = position

    def __str__(self):
        return "Symbol(grapheme={}, template={}, rtl={}, position={})".format(self.grapheme, self.template, self.rtl, self.position)

    def __eq__(self, other):
        if self.grapheme != other.grapheme:
            return False
        if self.template != other.template:
            return False
        if self.rtl != other.rtl:
            return False
        if self.position != other.position:
            return False
        return True

class FfiConverterTypeSymbol(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Symbol(
            grapheme=FfiConverterOptionalString.read(buf),
            template=FfiConverterOptionalString.read(buf),
            rtl=FfiConverterOptionalBool.read(buf),
            position=FfiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalString.write(value.grapheme, buf)
        FfiConverterOptionalString.write(value.template, buf)
        FfiConverterOptionalBool.write(value.rtl, buf)
        FfiConverterOptionalUInt32.write(value.position, buf)


class UnspentTransactionOutput:

    def __init__(self, txid, outnum, amount_millisatoshi, address, reserved, reserved_to_block):
        self.txid = txid
        self.outnum = outnum
        self.amount_millisatoshi = amount_millisatoshi
        self.address = address
        self.reserved = reserved
        self.reserved_to_block = reserved_to_block

    def __str__(self):
        return "UnspentTransactionOutput(txid={}, outnum={}, amount_millisatoshi={}, address={}, reserved={}, reserved_to_block={})".format(self.txid, self.outnum, self.amount_millisatoshi, self.address, self.reserved, self.reserved_to_block)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.outnum != other.outnum:
            return False
        if self.amount_millisatoshi != other.amount_millisatoshi:
            return False
        if self.address != other.address:
            return False
        if self.reserved != other.reserved:
            return False
        if self.reserved_to_block != other.reserved_to_block:
            return False
        return True

class FfiConverterTypeUnspentTransactionOutput(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UnspentTransactionOutput(
            txid=FfiConverterSequenceUInt8.read(buf),
            outnum=FfiConverterUInt32.read(buf),
            amount_millisatoshi=FfiConverterUInt64.read(buf),
            address=FfiConverterString.read(buf),
            reserved=FfiConverterBool.read(buf),
            reserved_to_block=FfiConverterUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterSequenceUInt8.write(value.txid, buf)
        FfiConverterUInt32.write(value.outnum, buf)
        FfiConverterUInt64.write(value.amount_millisatoshi, buf)
        FfiConverterString.write(value.address, buf)
        FfiConverterBool.write(value.reserved, buf)
        FfiConverterUInt32.write(value.reserved_to_block, buf)


class UrlSuccessActionData:

    def __init__(self, description, url):
        self.description = description
        self.url = url

    def __str__(self):
        return "UrlSuccessActionData(description={}, url={})".format(self.description, self.url)

    def __eq__(self, other):
        if self.description != other.description:
            return False
        if self.url != other.url:
            return False
        return True

class FfiConverterTypeUrlSuccessActionData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UrlSuccessActionData(
            description=FfiConverterString.read(buf),
            url=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.description, buf)
        FfiConverterString.write(value.url, buf)




class BreezEvent:
    def __init__(self):
        raise RuntimeError("BreezEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NEW_BLOCK(object):
        def __init__(self,block):
            
            self.block = block
            

        def __str__(self):
            return "BreezEvent.NEW_BLOCK(block={})".format(self.block)

        def __eq__(self, other):
            if not other.is_new_block():
                return False
            if self.block != other.block:
                return False
            return True
    class INVOICE_PAID(object):
        def __init__(self,details):
            
            self.details = details
            

        def __str__(self):
            return "BreezEvent.INVOICE_PAID(details={})".format(self.details)

        def __eq__(self, other):
            if not other.is_invoice_paid():
                return False
            if self.details != other.details:
                return False
            return True
    class SYNCED(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "BreezEvent.SYNCED()".format()

        def __eq__(self, other):
            if not other.is_synced():
                return False
            return True
    class PAYMENT_SUCCEED(object):
        def __init__(self,details):
            
            self.details = details
            

        def __str__(self):
            return "BreezEvent.PAYMENT_SUCCEED(details={})".format(self.details)

        def __eq__(self, other):
            if not other.is_payment_succeed():
                return False
            if self.details != other.details:
                return False
            return True
    class PAYMENT_FAILED(object):
        def __init__(self,details):
            
            self.details = details
            

        def __str__(self):
            return "BreezEvent.PAYMENT_FAILED(details={})".format(self.details)

        def __eq__(self, other):
            if not other.is_payment_failed():
                return False
            if self.details != other.details:
                return False
            return True
    class BACKUP_STARTED(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "BreezEvent.BACKUP_STARTED()".format()

        def __eq__(self, other):
            if not other.is_backup_started():
                return False
            return True
    class BACKUP_SUCCEEDED(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "BreezEvent.BACKUP_SUCCEEDED()".format()

        def __eq__(self, other):
            if not other.is_backup_succeeded():
                return False
            return True
    class BACKUP_FAILED(object):
        def __init__(self,details):
            
            self.details = details
            

        def __str__(self):
            return "BreezEvent.BACKUP_FAILED(details={})".format(self.details)

        def __eq__(self, other):
            if not other.is_backup_failed():
                return False
            if self.details != other.details:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_new_block(self):
        return isinstance(self, BreezEvent.NEW_BLOCK)
    def is_invoice_paid(self):
        return isinstance(self, BreezEvent.INVOICE_PAID)
    def is_synced(self):
        return isinstance(self, BreezEvent.SYNCED)
    def is_payment_succeed(self):
        return isinstance(self, BreezEvent.PAYMENT_SUCCEED)
    def is_payment_failed(self):
        return isinstance(self, BreezEvent.PAYMENT_FAILED)
    def is_backup_started(self):
        return isinstance(self, BreezEvent.BACKUP_STARTED)
    def is_backup_succeeded(self):
        return isinstance(self, BreezEvent.BACKUP_SUCCEEDED)
    def is_backup_failed(self):
        return isinstance(self, BreezEvent.BACKUP_FAILED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
BreezEvent.NEW_BLOCK = type("BreezEvent.NEW_BLOCK", (BreezEvent.NEW_BLOCK, BreezEvent,), {})
BreezEvent.INVOICE_PAID = type("BreezEvent.INVOICE_PAID", (BreezEvent.INVOICE_PAID, BreezEvent,), {})
BreezEvent.SYNCED = type("BreezEvent.SYNCED", (BreezEvent.SYNCED, BreezEvent,), {})
BreezEvent.PAYMENT_SUCCEED = type("BreezEvent.PAYMENT_SUCCEED", (BreezEvent.PAYMENT_SUCCEED, BreezEvent,), {})
BreezEvent.PAYMENT_FAILED = type("BreezEvent.PAYMENT_FAILED", (BreezEvent.PAYMENT_FAILED, BreezEvent,), {})
BreezEvent.BACKUP_STARTED = type("BreezEvent.BACKUP_STARTED", (BreezEvent.BACKUP_STARTED, BreezEvent,), {})
BreezEvent.BACKUP_SUCCEEDED = type("BreezEvent.BACKUP_SUCCEEDED", (BreezEvent.BACKUP_SUCCEEDED, BreezEvent,), {})
BreezEvent.BACKUP_FAILED = type("BreezEvent.BACKUP_FAILED", (BreezEvent.BACKUP_FAILED, BreezEvent,), {})




class FfiConverterTypeBreezEvent(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return BreezEvent.NEW_BLOCK(
                FfiConverterUInt32.read(buf),
            )
        if variant == 2:
            return BreezEvent.INVOICE_PAID(
                FfiConverterTypeInvoicePaidDetails.read(buf),
            )
        if variant == 3:
            return BreezEvent.SYNCED(
            )
        if variant == 4:
            return BreezEvent.PAYMENT_SUCCEED(
                FfiConverterTypePayment.read(buf),
            )
        if variant == 5:
            return BreezEvent.PAYMENT_FAILED(
                FfiConverterTypePaymentFailedData.read(buf),
            )
        if variant == 6:
            return BreezEvent.BACKUP_STARTED(
            )
        if variant == 7:
            return BreezEvent.BACKUP_SUCCEEDED(
            )
        if variant == 8:
            return BreezEvent.BACKUP_FAILED(
                FfiConverterTypeBackupFailedData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_new_block():
            buf.writeI32(1)
            FfiConverterUInt32.write(value.block, buf)
        if value.is_invoice_paid():
            buf.writeI32(2)
            FfiConverterTypeInvoicePaidDetails.write(value.details, buf)
        if value.is_synced():
            buf.writeI32(3)
        if value.is_payment_succeed():
            buf.writeI32(4)
            FfiConverterTypePayment.write(value.details, buf)
        if value.is_payment_failed():
            buf.writeI32(5)
            FfiConverterTypePaymentFailedData.write(value.details, buf)
        if value.is_backup_started():
            buf.writeI32(6)
        if value.is_backup_succeeded():
            buf.writeI32(7)
        if value.is_backup_failed():
            buf.writeI32(8)
            FfiConverterTypeBackupFailedData.write(value.details, buf)




class BuyBitcoinProvider(enum.Enum):
    MOONPAY = 1
    


class FfiConverterTypeBuyBitcoinProvider(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return BuyBitcoinProvider.MOONPAY
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == BuyBitcoinProvider.MOONPAY:
            buf.writeI32(1)




class ChannelState(enum.Enum):
    PENDING_OPEN = 1
    OPENED = 2
    PENDING_CLOSE = 3
    CLOSED = 4
    


class FfiConverterTypeChannelState(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ChannelState.PENDING_OPEN
        if variant == 2:
            return ChannelState.OPENED
        if variant == 3:
            return ChannelState.PENDING_CLOSE
        if variant == 4:
            return ChannelState.CLOSED
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ChannelState.PENDING_OPEN:
            buf.writeI32(1)
        if value == ChannelState.OPENED:
            buf.writeI32(2)
        if value == ChannelState.PENDING_CLOSE:
            buf.writeI32(3)
        if value == ChannelState.CLOSED:
            buf.writeI32(4)




class EnvironmentType(enum.Enum):
    PRODUCTION = 1
    STAGING = 2
    


class FfiConverterTypeEnvironmentType(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return EnvironmentType.PRODUCTION
        if variant == 2:
            return EnvironmentType.STAGING
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == EnvironmentType.PRODUCTION:
            buf.writeI32(1)
        if value == EnvironmentType.STAGING:
            buf.writeI32(2)




class FeeratePreset(enum.Enum):
    REGULAR = 1
    ECONOMY = 2
    PRIORITY = 3
    


class FfiConverterTypeFeeratePreset(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return FeeratePreset.REGULAR
        if variant == 2:
            return FeeratePreset.ECONOMY
        if variant == 3:
            return FeeratePreset.PRIORITY
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == FeeratePreset.REGULAR:
            buf.writeI32(1)
        if value == FeeratePreset.ECONOMY:
            buf.writeI32(2)
        if value == FeeratePreset.PRIORITY:
            buf.writeI32(3)




class InputType:
    def __init__(self):
        raise RuntimeError("InputType cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BITCOIN_ADDRESS(object):
        def __init__(self,address):
            
            self.address = address
            

        def __str__(self):
            return "InputType.BITCOIN_ADDRESS(address={})".format(self.address)

        def __eq__(self, other):
            if not other.is_bitcoin_address():
                return False
            if self.address != other.address:
                return False
            return True
    class BOLT11(object):
        def __init__(self,invoice):
            
            self.invoice = invoice
            

        def __str__(self):
            return "InputType.BOLT11(invoice={})".format(self.invoice)

        def __eq__(self, other):
            if not other.is_bolt11():
                return False
            if self.invoice != other.invoice:
                return False
            return True
    class NODE_ID(object):
        def __init__(self,node_id):
            
            self.node_id = node_id
            

        def __str__(self):
            return "InputType.NODE_ID(node_id={})".format(self.node_id)

        def __eq__(self, other):
            if not other.is_node_id():
                return False
            if self.node_id != other.node_id:
                return False
            return True
    class URL(object):
        def __init__(self,url):
            
            self.url = url
            

        def __str__(self):
            return "InputType.URL(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_url():
                return False
            if self.url != other.url:
                return False
            return True
    class LN_URL_PAY(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "InputType.LN_URL_PAY(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_ln_url_pay():
                return False
            if self.data != other.data:
                return False
            return True
    class LN_URL_WITHDRAW(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "InputType.LN_URL_WITHDRAW(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_ln_url_withdraw():
                return False
            if self.data != other.data:
                return False
            return True
    class LN_URL_AUTH(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "InputType.LN_URL_AUTH(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_ln_url_auth():
                return False
            if self.data != other.data:
                return False
            return True
    class LN_URL_ERROR(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "InputType.LN_URL_ERROR(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_ln_url_error():
                return False
            if self.data != other.data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bitcoin_address(self):
        return isinstance(self, InputType.BITCOIN_ADDRESS)
    def is_bolt11(self):
        return isinstance(self, InputType.BOLT11)
    def is_node_id(self):
        return isinstance(self, InputType.NODE_ID)
    def is_url(self):
        return isinstance(self, InputType.URL)
    def is_ln_url_pay(self):
        return isinstance(self, InputType.LN_URL_PAY)
    def is_ln_url_withdraw(self):
        return isinstance(self, InputType.LN_URL_WITHDRAW)
    def is_ln_url_auth(self):
        return isinstance(self, InputType.LN_URL_AUTH)
    def is_ln_url_error(self):
        return isinstance(self, InputType.LN_URL_ERROR)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
InputType.BITCOIN_ADDRESS = type("InputType.BITCOIN_ADDRESS", (InputType.BITCOIN_ADDRESS, InputType,), {})
InputType.BOLT11 = type("InputType.BOLT11", (InputType.BOLT11, InputType,), {})
InputType.NODE_ID = type("InputType.NODE_ID", (InputType.NODE_ID, InputType,), {})
InputType.URL = type("InputType.URL", (InputType.URL, InputType,), {})
InputType.LN_URL_PAY = type("InputType.LN_URL_PAY", (InputType.LN_URL_PAY, InputType,), {})
InputType.LN_URL_WITHDRAW = type("InputType.LN_URL_WITHDRAW", (InputType.LN_URL_WITHDRAW, InputType,), {})
InputType.LN_URL_AUTH = type("InputType.LN_URL_AUTH", (InputType.LN_URL_AUTH, InputType,), {})
InputType.LN_URL_ERROR = type("InputType.LN_URL_ERROR", (InputType.LN_URL_ERROR, InputType,), {})




class FfiConverterTypeInputType(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return InputType.BITCOIN_ADDRESS(
                FfiConverterTypeBitcoinAddressData.read(buf),
            )
        if variant == 2:
            return InputType.BOLT11(
                FfiConverterTypeLnInvoice.read(buf),
            )
        if variant == 3:
            return InputType.NODE_ID(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return InputType.URL(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return InputType.LN_URL_PAY(
                FfiConverterTypeLnUrlPayRequestData.read(buf),
            )
        if variant == 6:
            return InputType.LN_URL_WITHDRAW(
                FfiConverterTypeLnUrlWithdrawRequestData.read(buf),
            )
        if variant == 7:
            return InputType.LN_URL_AUTH(
                FfiConverterTypeLnUrlAuthRequestData.read(buf),
            )
        if variant == 8:
            return InputType.LN_URL_ERROR(
                FfiConverterTypeLnUrlErrorData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_bitcoin_address():
            buf.writeI32(1)
            FfiConverterTypeBitcoinAddressData.write(value.address, buf)
        if value.is_bolt11():
            buf.writeI32(2)
            FfiConverterTypeLnInvoice.write(value.invoice, buf)
        if value.is_node_id():
            buf.writeI32(3)
            FfiConverterString.write(value.node_id, buf)
        if value.is_url():
            buf.writeI32(4)
            FfiConverterString.write(value.url, buf)
        if value.is_ln_url_pay():
            buf.writeI32(5)
            FfiConverterTypeLnUrlPayRequestData.write(value.data, buf)
        if value.is_ln_url_withdraw():
            buf.writeI32(6)
            FfiConverterTypeLnUrlWithdrawRequestData.write(value.data, buf)
        if value.is_ln_url_auth():
            buf.writeI32(7)
            FfiConverterTypeLnUrlAuthRequestData.write(value.data, buf)
        if value.is_ln_url_error():
            buf.writeI32(8)
            FfiConverterTypeLnUrlErrorData.write(value.data, buf)




class LnUrlCallbackStatus:
    def __init__(self):
        raise RuntimeError("LnUrlCallbackStatus cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class OK(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "LnUrlCallbackStatus.OK()".format()

        def __eq__(self, other):
            if not other.is_ok():
                return False
            return True
    class ERROR_STATUS(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "LnUrlCallbackStatus.ERROR_STATUS(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_error_status():
                return False
            if self.data != other.data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_ok(self):
        return isinstance(self, LnUrlCallbackStatus.OK)
    def is_error_status(self):
        return isinstance(self, LnUrlCallbackStatus.ERROR_STATUS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
LnUrlCallbackStatus.OK = type("LnUrlCallbackStatus.OK", (LnUrlCallbackStatus.OK, LnUrlCallbackStatus,), {})
LnUrlCallbackStatus.ERROR_STATUS = type("LnUrlCallbackStatus.ERROR_STATUS", (LnUrlCallbackStatus.ERROR_STATUS, LnUrlCallbackStatus,), {})




class FfiConverterTypeLnUrlCallbackStatus(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return LnUrlCallbackStatus.OK(
            )
        if variant == 2:
            return LnUrlCallbackStatus.ERROR_STATUS(
                FfiConverterTypeLnUrlErrorData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_ok():
            buf.writeI32(1)
        if value.is_error_status():
            buf.writeI32(2)
            FfiConverterTypeLnUrlErrorData.write(value.data, buf)




class LnUrlPayResult:
    def __init__(self):
        raise RuntimeError("LnUrlPayResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ENDPOINT_SUCCESS(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "LnUrlPayResult.ENDPOINT_SUCCESS(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_endpoint_success():
                return False
            if self.data != other.data:
                return False
            return True
    class ENDPOINT_ERROR(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "LnUrlPayResult.ENDPOINT_ERROR(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_endpoint_error():
                return False
            if self.data != other.data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_endpoint_success(self):
        return isinstance(self, LnUrlPayResult.ENDPOINT_SUCCESS)
    def is_endpoint_error(self):
        return isinstance(self, LnUrlPayResult.ENDPOINT_ERROR)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
LnUrlPayResult.ENDPOINT_SUCCESS = type("LnUrlPayResult.ENDPOINT_SUCCESS", (LnUrlPayResult.ENDPOINT_SUCCESS, LnUrlPayResult,), {})
LnUrlPayResult.ENDPOINT_ERROR = type("LnUrlPayResult.ENDPOINT_ERROR", (LnUrlPayResult.ENDPOINT_ERROR, LnUrlPayResult,), {})




class FfiConverterTypeLnUrlPayResult(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return LnUrlPayResult.ENDPOINT_SUCCESS(
                FfiConverterOptionalTypeSuccessActionProcessed.read(buf),
            )
        if variant == 2:
            return LnUrlPayResult.ENDPOINT_ERROR(
                FfiConverterTypeLnUrlErrorData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_endpoint_success():
            buf.writeI32(1)
            FfiConverterOptionalTypeSuccessActionProcessed.write(value.data, buf)
        if value.is_endpoint_error():
            buf.writeI32(2)
            FfiConverterTypeLnUrlErrorData.write(value.data, buf)




class Network(enum.Enum):
    BITCOIN = 1
    TESTNET = 2
    SIGNET = 3
    REGTEST = 4
    


class FfiConverterTypeNetwork(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return Network.BITCOIN
        if variant == 2:
            return Network.TESTNET
        if variant == 3:
            return Network.SIGNET
        if variant == 4:
            return Network.REGTEST
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == Network.BITCOIN:
            buf.writeI32(1)
        if value == Network.TESTNET:
            buf.writeI32(2)
        if value == Network.SIGNET:
            buf.writeI32(3)
        if value == Network.REGTEST:
            buf.writeI32(4)




class NodeConfig:
    def __init__(self):
        raise RuntimeError("NodeConfig cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class GREENLIGHT(object):
        def __init__(self,config):
            
            self.config = config
            

        def __str__(self):
            return "NodeConfig.GREENLIGHT(config={})".format(self.config)

        def __eq__(self, other):
            if not other.is_greenlight():
                return False
            if self.config != other.config:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_greenlight(self):
        return isinstance(self, NodeConfig.GREENLIGHT)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
NodeConfig.GREENLIGHT = type("NodeConfig.GREENLIGHT", (NodeConfig.GREENLIGHT, NodeConfig,), {})




class FfiConverterTypeNodeConfig(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return NodeConfig.GREENLIGHT(
                FfiConverterTypeGreenlightNodeConfig.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_greenlight():
            buf.writeI32(1)
            FfiConverterTypeGreenlightNodeConfig.write(value.config, buf)




class PaymentDetails:
    def __init__(self):
        raise RuntimeError("PaymentDetails cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class LN(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "PaymentDetails.LN(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_ln():
                return False
            if self.data != other.data:
                return False
            return True
    class CLOSED_CHANNEL(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "PaymentDetails.CLOSED_CHANNEL(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_closed_channel():
                return False
            if self.data != other.data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_ln(self):
        return isinstance(self, PaymentDetails.LN)
    def is_closed_channel(self):
        return isinstance(self, PaymentDetails.CLOSED_CHANNEL)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
PaymentDetails.LN = type("PaymentDetails.LN", (PaymentDetails.LN, PaymentDetails,), {})
PaymentDetails.CLOSED_CHANNEL = type("PaymentDetails.CLOSED_CHANNEL", (PaymentDetails.CLOSED_CHANNEL, PaymentDetails,), {})




class FfiConverterTypePaymentDetails(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return PaymentDetails.LN(
                FfiConverterTypeLnPaymentDetails.read(buf),
            )
        if variant == 2:
            return PaymentDetails.CLOSED_CHANNEL(
                FfiConverterTypeClosedChannelPaymentDetails.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_ln():
            buf.writeI32(1)
            FfiConverterTypeLnPaymentDetails.write(value.data, buf)
        if value.is_closed_channel():
            buf.writeI32(2)
            FfiConverterTypeClosedChannelPaymentDetails.write(value.data, buf)




class PaymentType(enum.Enum):
    SENT = 1
    RECEIVED = 2
    CLOSED_CHANNEL = 3
    


class FfiConverterTypePaymentType(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return PaymentType.SENT
        if variant == 2:
            return PaymentType.RECEIVED
        if variant == 3:
            return PaymentType.CLOSED_CHANNEL
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == PaymentType.SENT:
            buf.writeI32(1)
        if value == PaymentType.RECEIVED:
            buf.writeI32(2)
        if value == PaymentType.CLOSED_CHANNEL:
            buf.writeI32(3)




class PaymentTypeFilter(enum.Enum):
    SENT = 1
    RECEIVED = 2
    ALL = 3
    


class FfiConverterTypePaymentTypeFilter(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return PaymentTypeFilter.SENT
        if variant == 2:
            return PaymentTypeFilter.RECEIVED
        if variant == 3:
            return PaymentTypeFilter.ALL
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == PaymentTypeFilter.SENT:
            buf.writeI32(1)
        if value == PaymentTypeFilter.RECEIVED:
            buf.writeI32(2)
        if value == PaymentTypeFilter.ALL:
            buf.writeI32(3)




class ReverseSwapStatus(enum.Enum):
    INITIAL = 1
    IN_PROGRESS = 2
    CANCELLED = 3
    COMPLETED_SEEN = 4
    COMPLETED_CONFIRMED = 5
    


class FfiConverterTypeReverseSwapStatus(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ReverseSwapStatus.INITIAL
        if variant == 2:
            return ReverseSwapStatus.IN_PROGRESS
        if variant == 3:
            return ReverseSwapStatus.CANCELLED
        if variant == 4:
            return ReverseSwapStatus.COMPLETED_SEEN
        if variant == 5:
            return ReverseSwapStatus.COMPLETED_CONFIRMED
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ReverseSwapStatus.INITIAL:
            buf.writeI32(1)
        if value == ReverseSwapStatus.IN_PROGRESS:
            buf.writeI32(2)
        if value == ReverseSwapStatus.CANCELLED:
            buf.writeI32(3)
        if value == ReverseSwapStatus.COMPLETED_SEEN:
            buf.writeI32(4)
        if value == ReverseSwapStatus.COMPLETED_CONFIRMED:
            buf.writeI32(5)




class SuccessActionProcessed:
    def __init__(self):
        raise RuntimeError("SuccessActionProcessed cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class AES(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "SuccessActionProcessed.AES(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_aes():
                return False
            if self.data != other.data:
                return False
            return True
    class MESSAGE(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "SuccessActionProcessed.MESSAGE(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_message():
                return False
            if self.data != other.data:
                return False
            return True
    class URL(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "SuccessActionProcessed.URL(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_url():
                return False
            if self.data != other.data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_aes(self):
        return isinstance(self, SuccessActionProcessed.AES)
    def is_message(self):
        return isinstance(self, SuccessActionProcessed.MESSAGE)
    def is_url(self):
        return isinstance(self, SuccessActionProcessed.URL)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
SuccessActionProcessed.AES = type("SuccessActionProcessed.AES", (SuccessActionProcessed.AES, SuccessActionProcessed,), {})
SuccessActionProcessed.MESSAGE = type("SuccessActionProcessed.MESSAGE", (SuccessActionProcessed.MESSAGE, SuccessActionProcessed,), {})
SuccessActionProcessed.URL = type("SuccessActionProcessed.URL", (SuccessActionProcessed.URL, SuccessActionProcessed,), {})




class FfiConverterTypeSuccessActionProcessed(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return SuccessActionProcessed.AES(
                FfiConverterTypeAesSuccessActionDataDecrypted.read(buf),
            )
        if variant == 2:
            return SuccessActionProcessed.MESSAGE(
                FfiConverterTypeMessageSuccessActionData.read(buf),
            )
        if variant == 3:
            return SuccessActionProcessed.URL(
                FfiConverterTypeUrlSuccessActionData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_aes():
            buf.writeI32(1)
            FfiConverterTypeAesSuccessActionDataDecrypted.write(value.data, buf)
        if value.is_message():
            buf.writeI32(2)
            FfiConverterTypeMessageSuccessActionData.write(value.data, buf)
        if value.is_url():
            buf.writeI32(3)
            FfiConverterTypeUrlSuccessActionData.write(value.data, buf)




class SwapStatus(enum.Enum):
    INITIAL = 1
    EXPIRED = 2
    


class FfiConverterTypeSwapStatus(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return SwapStatus.INITIAL
        if variant == 2:
            return SwapStatus.EXPIRED
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == SwapStatus.INITIAL:
            buf.writeI32(1)
        if value == SwapStatus.EXPIRED:
            buf.writeI32(2)



# SdkError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class SdkError(Exception):
        pass
    
    class Generic(SdkError):
        def __str__(self):
            return "SdkError.Generic({})".format(repr(super().__str__()))

    SdkError.Generic = Generic
    class InitFailed(SdkError):
        def __str__(self):
            return "SdkError.InitFailed({})".format(repr(super().__str__()))

    SdkError.InitFailed = InitFailed
    class LspConnectFailed(SdkError):
        def __str__(self):
            return "SdkError.LspConnectFailed({})".format(repr(super().__str__()))

    SdkError.LspConnectFailed = LspConnectFailed
    class LspOpenChannelNotSupported(SdkError):
        def __str__(self):
            return "SdkError.LspOpenChannelNotSupported({})".format(repr(super().__str__()))

    SdkError.LspOpenChannelNotSupported = LspOpenChannelNotSupported
    class PersistenceFailure(SdkError):
        def __str__(self):
            return "SdkError.PersistenceFailure({})".format(repr(super().__str__()))

    SdkError.PersistenceFailure = PersistenceFailure
    class ReceivePaymentFailed(SdkError):
        def __str__(self):
            return "SdkError.ReceivePaymentFailed({})".format(repr(super().__str__()))

    SdkError.ReceivePaymentFailed = ReceivePaymentFailed
SdkError = UniFFIExceptionTmpNamespace.SdkError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeSdkError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return SdkError.Generic(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return SdkError.InitFailed(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return SdkError.LspConnectFailed(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return SdkError.LspOpenChannelNotSupported(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return SdkError.PersistenceFailure(
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return SdkError.ReceivePaymentFailed(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, SdkError.Generic):
            buf.writeI32(1)
        if isinstance(value, SdkError.InitFailed):
            buf.writeI32(2)
        if isinstance(value, SdkError.LspConnectFailed):
            buf.writeI32(3)
        if isinstance(value, SdkError.LspOpenChannelNotSupported):
            buf.writeI32(4)
        if isinstance(value, SdkError.PersistenceFailure):
            buf.writeI32(5)
        if isinstance(value, SdkError.ReceivePaymentFailed):
            buf.writeI32(6)



import threading

class ConcurrentHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._left_map = {}  # type: Dict[Handle, Any]
        self._right_map = {}  # type: Dict[Any, Handle]

        self._lock = threading.Lock()
        self._current_handle = 0
        self._stride = 1


    def insert(self, obj):
        with self._lock:
            if obj in self._right_map:
                return self._right_map[obj]
            else:
                handle = self._current_handle
                self._current_handle += self._stride
                self._left_map[handle] = obj
                self._right_map[obj] = handle
                return handle

    def get(self, handle):
        with self._lock:
            return self._left_map.get(handle)

    def remove(self, handle):
        with self._lock:
            if handle in self._left_map:
                obj = self._left_map.pop(handle)
                del self._right_map[obj]
                return obj

# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
IDX_CALLBACK_FREE = 0

class FfiConverterCallbackInterface:
    _handle_map = ConcurrentHandleMap()

    def __init__(self, cb):
        self._foreign_callback = cb

    def drop(self, handle):
        self.__class__._handle_map.remove(handle)

    @classmethod
    def lift(cls, handle):
        obj = cls._handle_map.get(handle)
        if not obj:
            raise InternalError("The object in the handle map has been dropped already")

        return obj

    @classmethod
    def read(cls, buf):
        handle = buf.readU64()
        cls.lift(handle)

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.writeU64(cls.lower(cb))

# Declaration and FfiConverters for EventListener Callback Interface

class EventListener:
    def on_event(e):
        raise NotImplementedError

    

def py_foreignCallbackCallbackInterfaceEventListener(handle, method, args, buf_ptr):
    
    def invoke_on_event(python_callback, args):
        with args.consumeWithStream() as buf:
            rval = python_callback.on_event(
                FfiConverterTypeBreezEvent.read(buf)
                )
        return RustBuffer.alloc(0)
        

    cb = FfiConverterCallbackInterfaceEventListener.lift(handle)
    if not cb:
        raise InternalError("No callback in handlemap; this is a Uniffi bug")

    if method == IDX_CALLBACK_FREE:
        FfiConverterCallbackInterfaceEventListener.drop(handle)
        # No return value.
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
        return 0

    if method == 1:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs` for details
        try:
            # Successful return
            buf_ptr[0] = invoke_on_event(cb, args)
            return 1
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = FfiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return -1
    

    # This should never happen, because an out of bounds method index won't
    # ever be used. Once we can catch errors, we should return an InternalException.
    # https://github.com/mozilla/uniffi-rs/issues/351

    # An unexpected error happened.
    # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
    return -1

# We need to keep this function reference alive:
# if they get GC'd while in use then UniFFI internals could attempt to call a function
# that is in freed memory.
# That would be...uh...bad. Yeah, that's the word. Bad.
foreignCallbackCallbackInterfaceEventListener = FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceEventListener)

# The FfiConverter which transforms the Callbacks in to Handles to pass to Rust.
rust_call(lambda err: _UniFFILib.ffi_breez_sdk_715c_EventListener_init_callback(foreignCallbackCallbackInterfaceEventListener, err))
FfiConverterCallbackInterfaceEventListener = FfiConverterCallbackInterface(foreignCallbackCallbackInterfaceEventListener)





# Declaration and FfiConverters for LogStream Callback Interface

class LogStream:
    def log(l):
        raise NotImplementedError

    

def py_foreignCallbackCallbackInterfaceLogStream(handle, method, args, buf_ptr):
    
    def invoke_log(python_callback, args):
        with args.consumeWithStream() as buf:
            rval = python_callback.log(
                FfiConverterTypeLogEntry.read(buf)
                )
        return RustBuffer.alloc(0)
        

    cb = FfiConverterCallbackInterfaceLogStream.lift(handle)
    if not cb:
        raise InternalError("No callback in handlemap; this is a Uniffi bug")

    if method == IDX_CALLBACK_FREE:
        FfiConverterCallbackInterfaceLogStream.drop(handle)
        # No return value.
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
        return 0

    if method == 1:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs` for details
        try:
            # Successful return
            buf_ptr[0] = invoke_log(cb, args)
            return 1
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = FfiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return -1
    

    # This should never happen, because an out of bounds method index won't
    # ever be used. Once we can catch errors, we should return an InternalException.
    # https://github.com/mozilla/uniffi-rs/issues/351

    # An unexpected error happened.
    # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
    return -1

# We need to keep this function reference alive:
# if they get GC'd while in use then UniFFI internals could attempt to call a function
# that is in freed memory.
# That would be...uh...bad. Yeah, that's the word. Bad.
foreignCallbackCallbackInterfaceLogStream = FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceLogStream)

# The FfiConverter which transforms the Callbacks in to Handles to pass to Rust.
rust_call(lambda err: _UniFFILib.ffi_breez_sdk_715c_LogStream_init_callback(foreignCallbackCallbackInterfaceLogStream, err))
FfiConverterCallbackInterfaceLogStream = FfiConverterCallbackInterface(foreignCallbackCallbackInterfaceLogStream)



class FfiConverterOptionalUInt32(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalUInt64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalInt64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalBool(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterBool.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterBool.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeGreenlightCredentials(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeGreenlightCredentials.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeGreenlightCredentials.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeLnInvoice(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeLnInvoice.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeLnInvoice.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeLspInformation(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeLspInformation.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeLspInformation.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeOpeningFeeParams(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeOpeningFeeParams.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeOpeningFeeParams.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypePayment(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypePayment.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypePayment.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeSwapInfo(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeSwapInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeSwapInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeSymbol(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeSymbol.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeSymbol.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeSuccessActionProcessed(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeSuccessActionProcessed.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeSuccessActionProcessed.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceUInt8(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceUInt8.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceUInt8.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceTypeLocaleOverrides(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceTypeLocaleOverrides.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceTypeLocaleOverrides.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceTypeLocalizedName(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceTypeLocalizedName.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceTypeLocalizedName.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterSequenceUInt8(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterUInt8.read(buf) for i in range(count)
        ]



class FfiConverterSequenceString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterString.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeFiatCurrency(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeFiatCurrency.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeFiatCurrency.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeLocaleOverrides(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeLocaleOverrides.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeLocaleOverrides.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeLocalizedName(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeLocalizedName.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeLocalizedName.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeLspInformation(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeLspInformation.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeLspInformation.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeOpeningFeeParams(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeOpeningFeeParams.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeOpeningFeeParams.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypePayment(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypePayment.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypePayment.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeRate(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeRate.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeRate.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeReverseSwapInfo(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeReverseSwapInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeReverseSwapInfo.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeRouteHint(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeRouteHint.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeRouteHint.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeRouteHintHop(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeRouteHintHop.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeRouteHintHop.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeSwapInfo(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeSwapInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeSwapInfo.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeUnspentTransactionOutput(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeUnspentTransactionOutput.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeUnspentTransactionOutput.read(buf) for i in range(count)
        ]

def connect(config,seed,listener):
    config = config
    
    seed = list(int(x) for x in seed)
    
    listener = listener
    
    return FfiConverterTypeBlockingBreezServices.lift(rust_call_with_error(FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_connect,
        FfiConverterTypeConfig.lower(config),
        FfiConverterSequenceUInt8.lower(seed),
        FfiConverterCallbackInterfaceEventListener.lower(listener)))



def set_log_stream(log_stream):
    log_stream = log_stream
    
    rust_call_with_error(FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_set_log_stream,
        FfiConverterCallbackInterfaceLogStream.lower(log_stream))


def parse_invoice(invoice):
    invoice = invoice
    
    return FfiConverterTypeLnInvoice.lift(rust_call_with_error(FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_parse_invoice,
        FfiConverterString.lower(invoice)))



def parse_input(s):
    s = s
    
    return FfiConverterTypeInputType.lift(rust_call_with_error(FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_parse_input,
        FfiConverterString.lower(s)))



def mnemonic_to_seed(phrase):
    phrase = phrase
    
    return FfiConverterSequenceUInt8.lift(rust_call_with_error(FfiConverterTypeSdkError,_UniFFILib.breez_sdk_715c_mnemonic_to_seed,
        FfiConverterString.lower(phrase)))



def default_config(env_type,api_key,node_config):
    env_type = env_type
    
    api_key = api_key
    
    node_config = node_config
    
    return FfiConverterTypeConfig.lift(rust_call(_UniFFILib.breez_sdk_715c_default_config,
        FfiConverterTypeEnvironmentType.lower(env_type),
        FfiConverterString.lower(api_key),
        FfiConverterTypeNodeConfig.lower(node_config)))



__all__ = [
    "InternalError",
    "BreezEvent",
    "BuyBitcoinProvider",
    "ChannelState",
    "EnvironmentType",
    "FeeratePreset",
    "InputType",
    "LnUrlCallbackStatus",
    "LnUrlPayResult",
    "Network",
    "NodeConfig",
    "PaymentDetails",
    "PaymentType",
    "PaymentTypeFilter",
    "ReverseSwapStatus",
    "SuccessActionProcessed",
    "SwapStatus",
    "AesSuccessActionDataDecrypted",
    "BackupFailedData",
    "BackupStatus",
    "BitcoinAddressData",
    "BuyBitcoinRequest",
    "BuyBitcoinResponse",
    "CheckMessageRequest",
    "CheckMessageResponse",
    "ClosedChannelPaymentDetails",
    "Config",
    "CurrencyInfo",
    "FiatCurrency",
    "GreenlightCredentials",
    "GreenlightNodeConfig",
    "InvoicePaidDetails",
    "LnInvoice",
    "LnPaymentDetails",
    "LnUrlAuthRequestData",
    "LnUrlErrorData",
    "LnUrlPayRequestData",
    "LnUrlWithdrawRequestData",
    "LocaleOverrides",
    "LocalizedName",
    "LogEntry",
    "LspInformation",
    "MessageSuccessActionData",
    "MetadataItem",
    "NodeState",
    "OpeningFeeParams",
    "OpeningFeeParamsMenu",
    "Payment",
    "PaymentFailedData",
    "Rate",
    "ReceiveOnchainRequest",
    "ReceivePaymentRequest",
    "ReceivePaymentResponse",
    "RecommendedFees",
    "ReverseSwapFeesRequest",
    "ReverseSwapInfo",
    "ReverseSwapPairInfo",
    "RouteHint",
    "RouteHintHop",
    "SignMessageRequest",
    "SignMessageResponse",
    "SwapInfo",
    "Symbol",
    "UnspentTransactionOutput",
    "UrlSuccessActionData",
    "connect",
    "set_log_stream",
    "parse_invoice",
    "parse_input",
    "mnemonic_to_seed",
    "default_config",
    "BlockingBreezServices",
    "SdkError",
    "LogStream",
    "EventListener",
]

